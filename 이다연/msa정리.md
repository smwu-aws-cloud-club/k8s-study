저는 이전에 정리했던 블로그 링크와 spring기반 msa를 구축할 때 사용되는 SpringWebFlux framework에 대해 공부한 내용을 정리했습니다!

https://dylee00.tistory.com/2

## msa

- 모놀리스
    - 모든 서비스 로직이 하나의 애플리케이션 형태로 패키지 되어 서비스 되고 애플리케이션에서 사용하는 데이터 또한 한 곳에 모인 데이터를 참조하여 서비스 하는 형태
    - 빠르게 바뀌는 환경에서는 유연하게 대처하기 힘듬
        - 단일 애플리케이션 중 일부 수정 → 다시 배포 → 시간이 오래 걸림
    - 일반적으로 서비스와 데이터가 연결되어 있음
- 마이크로 서비스 아키텍처
    - 마이크로서비스: 아주 작은 단위로 동작하는 서비스가 구동 되도록 시스템 및 소프트웨어의 구성과 구성 요소간의 관계를 정의한 아키텍처
    - 구성 요소
        - 서비스들 + 실행 환경
    - 서비스와 데이터가 분할되어 작은 서비스들이 여러 독립된 형태로 서비스를 제공
    - 하나의 큰 애플리케이션을 작은 애플리케이션으로 나누어 서비스
- 서비스 지향 아키텍처
    - 서비스들의 가용성을 보장하기 위해 일정 시간 동안 서비스 요청에 대한 반응이 없으면 기존 요청 경로를 차단하고 다른 경로로 요청 경로 변경 →서비스 라우팅, 서킷 브레이커 등으로 구현 가능
    - 서비스 간 상호 통신 시 권한에 관한 제어권이 서비스 자체에 있어야 함
    - 트랜잭션 → 서비스에서 발생하는 트랜잭션들에 대한 일관성 유지 필요 → 읽기 전용 데이터베이스와 쓰기 전용 데이터베이스 간의 데이터 일관성을 유지하기 위한 동기화 필요 → base 전략
    - 서비스 관리
        - 서비스들을 시각화해서 모니터링 할 수 있어야 함
    - 데이터
        - 마이크로 서비스 아키텍처 관점에서는 서비스에서 참조하는 데이터의 경계를 넘어서까지 참조해야 하는 연결 관계는 지양 → 서비스 내에서의 모든 기능이 참조하는 데이터는 같은 스키마를 참조하는 것을 권장
        - 데이터 간의 종속성을 분리하기 위해 마이크로서비스 단위별로 데이터베이스를 분리하는 것을 권장
            - 그러면 트랜잭션 처리는 어떻게? (즉, 분할된 서비스끼리 데이터를 어떻게 처리해야 할 것인지) → 설계 단계에서부터 서비스 수준에서 처리하거나 queue 매커니즘을 이용하여 데이터 동기화 필요
    - 공통된 기능
        - 공통된 기능을 라이브러리화 해서 일괄적으로 배포하고 관리할 것인지
        - 공통의 REST 서비스로 둘 것인지

## spring mvc vs spring webFlux

### 1) 웹 서버, 웹 애플리케이션 서버

- 웹 → HTTP 프로토콜 기반으로 데이터 전송 및 응답
- 웹 서버 → 클라이언트가 HTTP 요청하면 웹 서버가 HTTP 응답.
    - 정적 리소스 제공 + 기타 부가기능
    - nginx, apache
- 웹 어플리케이션 서버(was) → 클라이언트가 HTTP 요청하면 was가 HTTP응답
    - 프로그램 코드를 실행해서 애플리케이션 로직 수행하는 서버
    - tomcat
- 웹 시스템 구성 → 정적 리소스는 웹 서버가, 애플리케이션 로직같은 동적 처리가 필요하다면 웹 서버는 was에 요청을 위임 → was는 애플리케이션 로직 처리 전담

### 2) 서블릿

- 서블릿은 비즈니스 로직 영역을 제외한 전/후 모든 작업 다 지원해줌(공통되는 작업들 지원)
    - 서버 TCP/IP 대기, 소켓 연결
    - HTTP 요청 메시지 파싱해서 읽기
    - Content-Type 확인
    - HTTP 메시지 바디 내용 파싱
    - 저장 프로세스 실행
    - HTTP 응답 메시지 생성
    - TCP/IP에 응답 전달, 소켓 종료
- 서블릿을 이용한 HTTP 요청, 응답 흐름
    - 클라이언트가 HTTP 요청 → WAS는 요청 메시지를 기반으로 HttpServletRequest, HttpServletResponse 객체 생성 → 요청 URI에 해당하는 서블릿의 service() 호출 → 서블릿이 비즈니스 로직 수행 및 HttpServletResponse 객체에 응답 작성 → WAS가 HTTP 응답 메시지 생성하여 클라이언트에게 반환
- 서블릿 컨테이너
    - 서블릿을 지원하는 WAS를 서블릿 컨테이너라 부름(ex/Tomcat)
    - 서블릿 객체 생성, 초기화, 호출, 종료하는 생명주기 관리
    - 서블릿 객체는 싱글톤으로 관리
        - 최초 로딩 시점에 request, response 객체를 생성해 놓고 재사용(요청이 올 때마다 객체를 새로 생성하지 않음) → 모든 요청들은 동일한 서블릿 객체 인스턴스에 접근하므로 공유 변수 사용에 주의해야 함
    - 멀티 쓰레드 처리 지원

### 3) 멀티 쓰레드

- thread
    - 실행 흐름 → 애플리케이션 코드를 순차적으로 실행(한 번에 하나의 코드 라인만 수행)
    - 동시 처리가 필요하면 쓰레드를 추가로 생성해줘야 함
    - 자바에서  요청에 대한 thread 할당하는 방식(was의 멀티 쓰레드 환경에서 할당하는 방식)
        - thread pool에 있는 thread 를 할당받고 → 사용 후 thread pool에게 반납
- 클라이언트가 서버에게 요청을 보냄 → 서버(was)와 TCP/IP 커넥션 연결 → thread 할당 →thread로 was의 servlet 객체(request,response) 호출
- was는 멀티 쓰레드 지원
    - 따라서 개발자는 싱글 쓰레드 프로그래밍을 하듯이 편리하게 소스 코드 개발
    - 멀티 쓰레드 환경이므로 싱글톤 객체(서블릿, 스프링 빈)은 주의해서 사용

### 4) Spring MVC

- MVC 패턴
    - 클라이언트가 요청 보냄 → controller가 http 요청 받아서 비즈니스 로직 실행 및 데이터 접근 → model을 통해 필요한 데이터를 뷰로 전달 → 뷰는 클라이언트에게 화면을 그려서 보여줌
    - Model
        - View에 출력할 데이터를 담아둠
    - View
        - Model에 담겨있는 데이터를 활용해서 화면을 그리는 일에 집중
    - Controller
        - HTTP 요청을 받아 파라미터 검증, 비즈니스 로직 실행, 모델에 데이터 담는 역할
        - service 호출 → 비즈니스 로직 실행은 service 계층을 따로 만들어 실행
- Spring MVC
    1. 클라이언트 요청
    2. Dispatcher Servlet
        - 서블릿임
        - HTTP 요청을 Dispatcher Servlet이 받아 HandlerMapping으로 어떤 Cotroller가 이 요청을 처리할지 찾음
    3. Controller
        - 매핑된 컨트롤러 호출, 요청 데이터를 바탕으로 처리 로직 실행
    4. Service → Repository
        - 필요한 경우 Controller는 서비스나 리포지토리 호출
    5. Model 반환
        - Controller는 처리 결과를 Model 객체에 담아 반환
    6. ViewResolver
        - DispatcherServlet는 Controller가 리턴한 뷰 이름을 바탕으로 ViewResolver통해 뷰를 찾음
    7. View(or JSON)
        - View 객체가 최종 화면을 렌더링하거나 RestController, ResponseBody를 사용해 JSON으로 변환 후 클라이언트에게 반환

### 5) Spring WebFlux

- 반응형 및 비동기적인 웹 애플리케이션 개발을 지원하는 모듈 → Reactor 라이브러리 이용
- Reactor는 Netty 서버를 통해(WAS역할) 이벤트 기반 서버 환경을 제공하며 이를 이용해 비동기 방식의 non-blocking 요청을 통해 이벤트 기반의 반응형 스트림으로 데이터를 주고받음
- Spring WebFlux는 비동기 + 논블로킹 중심으로 설계되어 하나의 thread로 여러 개의 요청을 처리 가능
1. Netty
    - 자바 기반의 네트워크 애플리케이션 프레임워크 → 비동기식 이벤트 기반 서버를 만드는 데 사용됨
2. Reactive Stream
    - 비 동기적 이벤트 기반 응용 프로그램을 위한 스트림 처리 기술
        - Publisher가 Subscriber에게 데이터 제공, Subscriber는 데이터 처리하여 한 스트림 처리
    - MSA는 MVC처럼 Servlet 기반이 아닌 Reactive Stream 기반으로 동작
3. WebFlux가 MSA에 적합한 이유
    - 각 서비스가 독립적이고 외부 호출이 많음
        - msa는 각 서비스 간 통신이 많기 때문에 외부 api, db, message queue와 I/O 중심 작업을 자주 함 → webFlux는 이러한 작업을 논블로킹으로 처리하여 성능을 극대화함
    - 서비스 간 호출 흐름이 길게 존재함
        - blocking request를 사용하면 요청에 대한 결과가 나올 때 까지 대기 → 스레드가 계속 점유되어 리소스 고갈
        - webflux는 non-blocking request를 사용해 요청에 대한 결과가 반환되지 않아도 다른 작업 수행
    - 적은 스레드로 많은 요청 처리 가능
        - event loop 기반으로 요청 처리 → 적은 스레드로 많은 요청 처리 가능
    - 안정성 확보
        - WebFlux는 Reactive Streams 사양을 따름 → 처리할 수 있는 만큼만 데이터를 받음 → MSA에서 서비스 간 속도 차이가 날 때도 폭주 없이 처리량 조절 가능
