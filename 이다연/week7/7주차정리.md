### 로깅 아키텍처

- 클러스터-레벨 로깅
    - 쿠버네티스 클러스터에서 로그는 노드, 파드, 컨테이너와는 독립적으로 별도의 스토리지와 라이프 사이클을 가져야 함
    - 로그를 저장, 분석, 쿼리하기 위한 별도의 백엔드가 필요함

### 파드와 컨테이너 로그

- 파드 매니페스트로 실행중인 파드의 컨테이너에서 출력하는 로그 감시
    
    ```yaml
    apiVersion: v1
    kind: Pod
    metadata:
    	name: counter
    spec:
     containers:
     - name: count
       image: busybox:1.28
       args: [/bin/sh, -c,
                'i=0; while true; do echo "$i: $(date)"; i=$((i+1)); sleep 1; done']
    ```
    

### 노드가 컨테이너 로그를 처리하는 방법

- 컨테이너화된 애플리케이션의 표준 출력, 표준 입력 스트림에 의해 생성된 모든 출력 → 컨테이너 런타임이 처리하고 리디렉션 시킴
- 쿠버네티스의 경우 컨테이너 런타임이 표준 로깅 포맷(CRI)를 따르고, kubelet이 이 표준 포맷을 통해 로그를 수집 및 노출해서 `kubectl logs` 로 모든 로그를 볼 수 있음 → 따라서 쿠버네티스는 로그를 일관되게 수집하고 제공하는 구조를 가짐
- 컨테이너가 재시작해도 직전 1개의 로그는 유지되며
- 파드가 삭제되면 로그도 함께 사라짐

### 로그 로테이션

- k8s에서 컨테이너 로그를 어떻게 저장하고, 관리하고, 로테이션을 처리하는지
- kubelet이 로그를 자동으로 로테이트하도록 설정할 수 있음 → 로테이션을 설정하면 오래된 로그는 자동 삭제되고 최신 로그만 유지 가능
- 로그 로테이션 과정
    - 로테이션 구성 → kubelet은 컨테이너 로그를 로테이트하고 로깅 경로 구조 관리 → kubelet은 이 정보를 CRI를 사용하여 컨테이너 런타임에 전송 → 런타임은 지정된 위치에 컨테이러 로그를 기록함
- kubelet 설정 파일을 사용하여  [`containerLogMaxSize` 및 `containerLogMaxFiles`](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration)를 설정 가능함   →  이러한 설정을 통해 각 로그 파일의 최대 크기와 각 컨테이너에 허용되는 최대 파일 수를 각각 구성할 수 있음
- `kubectl logs`  실행 → 노드의 kubelet이 요청을 처리하고 로그 파일에서 직접 읽음 → kubelet은 로그 파일의 내용을 반환함

### 시스템 컴포넌트 로그

- 쿠버네티스 시스템 컴포넌트 → 어떤 것은 컨테이너로 실행되고, 어떤 것은 시스템 프로세스로 실행됨

| 컴포넌트 | 실행 장소 | 로그 확인 방법 |
| --- | --- | --- |
| kubelet, 컨테이너 런타임 | 컨테이너 밖에서 직접 실행(호스트에서 직접 실행) | 시스템 로그 |
| kube-apiserver, scheduler, controller-manager, etcd | 스태틱 파드로 실행(컨테이너 안에서 실행) | kubectl logs |
| kube-proxy | DaemonSet으로 각 노드에 배포
(컨테이너 안에서 실행) | kubectl logs |

### 클러스터-레벨 로깅 아키텍처

- 쿠버네티스는 기본적으로 클러스터-레벨 로깅을 제공하지 않지만 외부 로깅 시스템과 연동하거나 자체 구성을 통해 로깅 인프라를 구축할 수 있음
- 노드 로깅 에이전트(DaemonSet 로깅 에이전트)
    - 로깅 에이전트
        - 해당 노드의 모든 애플리케이션 컨테이너에서 로그 파일이 있는 디렉토리에 접근할 수 있는 컨테이너
    - kubelet이 stdout/stderr을 CRI 로그 포맷으로 기록하면 로깅 에이전트가 수집 후 로그를 노출하거나 로그를 백엔드로 푸시
    - 대표 예시: Fluentd, Logstash, Filebeat, Vector

### 사이드카 컨테이너 방식

- 파드에 별도 컨테이너를 붙여 로그를 tail 하여 stdout으로 출력
- 구성이 유연함 → 로그 포맷별로 별도 수집 가능
- 하지만 CPU/메모리 사용량이 증가하여 리소스 낭비 우려가 있음
- 로그 리디렉션용, logrotate 실행 용도에도 사용 가능

### 사이드카 + 로깅 에이전트

- 로그 수집 및 전송을 사이드카가 담당
- GCP, ElasticSearch, Kafka등으로 로그 전송

### 애플리케이션에서 직접 푸시

- 애플리케이션이 자체적으로 로그를 외부 시스템에 보냄
- 클러스터 외부 종속성이 생길 수 있음

### 리소스 모니터링 도구

- 쿠버네티스 클러스터에서 애플리케이션 리소스 사용량을 모니터링 하는 방식으로 리소스 메트릭 파이프라인, 완전한 메트릭 파이프라인이 있음

### 리소스 메트릭 파이프라인

- 가볍고 기본적인 리소스 모니터링용
- metrics-server가 각 노드의 kubelet으로 cpu, 메모리 사용량 수집
- kubectl top 명령어와 HPA가 이 정보를 사용
- kubelet은 컨테이너 런타임이나 cAdvisor로부터 통계를 얻음
- 이 정보는 metrics.k8s.io API를 통해 노출됨

### 완전한 메트릭 파이프라인

- 더 풍부한 메트릭(사용자 정의 메트릭, 외부 메트릭) 제공
- HPA 등에서 커스텀 조건으로 자동 스케일링 가능
- custom.metrics.k8s.io 및 external.metrics.k8s.io API 사용
- Phtometueus가 대표적인 구현체로 클러스터, 노드, 앱, 자체 메트릭까지 모니터링 가능
