# 1. 파드

## 1. 파드란 무엇인가?

- 쿠버네티스에서 생성하고 관리할 수 있는 배포 가능한 가장 작은 컴퓨팅 단위
- 하나 이상의 컨테이너 그룹 → 이 그룹은 스토리지, 네트워크 공유하고 컨테이너 구동 방식에 대한 명세를 가짐
- 파드의 콘텐츠들(컨테이너)는 항상 함께 배치, 스케줄되며 공유 콘텍스트(실행 환경)에서 실행됨
    - 파드의 공유 콘텍스트란?: 같은 네트워크, 같은 스토리지, 같은 리눅스 네임스페이스 등을 함께 사용하는 실행 환경 → 파드의 콘텍스트 내에서 개별 어플리케이션은 추가적으로 하위 격리(컨테이너)가 적용됨
- 파드는 공유 네임스페이스와 공유 파일시스템 볼륨이 있는 컨테이너들의 집합과 비슷

파드의 공유 콘텍스트는 리눅스 네임스페이스, 컨트롤 그룹(cgroup) 및 [컨테이너](https://kubernetes.io/ko/docs/concepts/containers/)를 격리하는 것과 같이 잠재적으로 다른 격리 요소들이다. 파드의 콘텍스트 내에서 개별 애플리케이션은 추가적으로 하위 격리가 적용된다.

파드는 공유 네임스페이스와 공유 파일시스템 볼륨이 있는 컨테이너들의 집합과 비슷하다.

# 2. 파드의 사용

```yaml
# pods/simple-pod.yaml
apiVersion: v1
kind: Pod
metadata:
	name: nginx
spec:
	containers:
	- name: nginx
	image: nginx:1.14.2
	ports:
	- containerPort: 80
```

파드 생성

```yaml
kubectl apply -f https://k8s.io/examples/pods/simple-pod.yaml
```

- 하지만 일반적으로 파드는 직접 생성하지 않고 워크로드리소스(Deployment)를 이용하여 생성

### 1. Workload resources for managing pods

- deployment, jobs 같은 workload resources를 사용하여 pods 생성
- 쿠버네티스 클러스터 파드의 사용 방식
    - 단일 컨테이너를 실행하는 파드
        - 파드 당 하나의 컨테이너
        - 파드 → 한 개의 컨테이너를 둘러싼 wrapper
        - 쿠버네티스는 컨테이너 대신 파드를 관리
        - 보통 파드는
    - 여러 컨테이너를 실행하는 파드
        - 함께 배치된 컨테이너들은 하나의 결합된 서비스 단위 형성 → 여러 개의 컨테이너들로 구성된 애플리케이션을 캡슐화
- 일반적으로 파드는 특정 애플리케이션의 단일 인스턴스를 실행하기 위한 것 → 애플리케이션을 수평적으로 확장하려면 각 인스턴스에 하나씩 여러 파드를 사용해야 함 ⇒ 이러한 여러 파드를 사용하는 것이 레플리케이션 → 복제된 파드들은 워크로드 리소스, 컨트롤러에 의해 그룹으로 생성되고 관리

### 2. 파드가 여러 컨테이너들을 관리하는 방법

- 파드는 응집력있는 서비스 단위를 형성하는 여러 협력 프로세스(컨테이너)를 지원하도록 설계 → 파드의 컨테이너는 클러스터의 동일한 물리, 가상 머신에서 자동으로 같은 위치에 배치되고 함께 스케줄됨
- 컨테이너는 리소스와 의존성을 공유하고, 통신하고, 종료 시기와 방법을 조정할 수 있음
- 파드는 파드에 속한 컨테이너에 네트워킹, 스토리지라는 두 가지 공유 리소스 제공

# 3. 파드 작업

- 사용자가 직접 개별 파드를 만들지 않는 이유? → 파드는 일회용 엔티티로 설계되었기 때문
- 파드가 생성될 때 → 새 파드는 클러스터의 노드에서 실행되도록 스케줄 됨
- 파드는 실행 완료, 파드 오브젝트 삭제, 리소스 부족으로 인한 파드 축출, 노드가 실패할 때까지 해당 노드에 남아 있음
- 파드 → 실행 환경
- 파드에서 실행되는 컨테이너 → 프로그램(프로세스)

### 1. 파드와 컨트롤러

- 워크로드 리소스를 이용하여 여러 파드를 만들고 관리
- 리소스에 대한 컨트롤러 → 파드 장애 시 복제, 롤아웃, 자동 복구 처리
    - 노드 실패 → 컨트롤러는 해당 노드의 파드가 작동을 중지했음을 인식 → 대체 파드 생성 → 스케줄러는 대체 파드를 정상 노드에 배치

### 2. 파드 템플릿

- 파드를 생성하기 위한 명세서. 디플로이먼트, 잡, 데몬셋 등
- 워크로드 리소스의 컨트롤러 → 워크로드 오브젝트 내부의  `PodTemplate` 을 사용하여 실제 파드를 생성
- 

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: hello
spec:
  template:
    # 여기서부터 파드 템플릿이다
    spec:
      containers:
      - name: hello
        image: busybox:1.28
        command: ['sh', '-c', 'echo "Hello, Kubernetes!" && sleep 3600']
      restartPolicy: OnFailure
```

- 파드 템플릿을 수정하거나 바꿔도 이미 존재하는 파드에는 직접적인 영향 x → 변경한 워크로드 리소스를 적용하려면 파드를 다시 생성해야 함
- 노드에서 kubelet → 파드 템플릿, 업데이트에 대한 상세 정보를 추상화 + 관심사 분리

# 4. 파드 갱신 및 교체

- 워크로드 리소스의 파드 템플릿 변경 → 컨트롤러는 변경된 템플릿 기반으로 신규 파드 생성
- 파드 갱신 작업의 제약?
    - 파드에 대한 대부분의 메타데이터 → 불변

# 5. 리소스 공유와 통신

- 파드는 파드에 속한 컨테이너 간의 데이터 공유와 통신 지원

## 1. 파드 스토리지

- 파드는 공유 스토리지 볼륨의 집합을 지정할 수 있음
- 파드의 모든 컨테이너 → 공유 볼륨에 접근 가능 → 해당 컨테이너가 데이터 공유 가능
- 볼륨 → 파드의 영구 데이터 유지

## 2. 파드 네트워킹

- 파드 → 고유한 IP 주소 할당 → 다른 파드에서 실행하는 컨테이너와 통신하려면 IP 네트워킹을 사용하여 통신
- 파드의 모든 컨테이너 → 네트워크 namespace 공유
- 파드 내부의 컨테이너
    - localhost를 사용하여 서로 통신 가능
    - IP주소와 포트 공간 공유

## 3. 컨테이너에 대한 특권 모드

- pod의 모든 컨테이너는 privileged flag를 사용하여 특권 모드를 활성화 할 수 있음 → os 관리(네트워크 스택 조작, 하드웨어 장치 접근)기능을 사용하려는 컨테이너에 유용함

## 4. 정적 파드

- kubelet demon에 의해 직접 관리(일반적인 pod는 control plane(deployment)에 의해 관리)
- 정적 파드는 항상 특정 노드의 kubelet 하나에 바인딩
- 정적 파드의 용도 → 자체 호스팅 컨트롤 플레인 실행 → kubelet을 사용하여 개별 컨트롤 플레인 컴포넌트 감독 → api 서버에서 보이지만 제어 x

## 5. 컨테이너 프로브

- probe → kubelet에 의해 주기적으로 실행되는 상태 진단
- `ExecAction`  → 컨테이너 런타임의 도움을 받아 수행
- `TCPSocketAction` → kubelet에 의해 직접 검사
- `HTTPGetAction` → kubelet에 의해 직접 검사

# 4. 파드 라이프사이클

- 파드의 라이프사이클: Pending → Running → 파드의 컨테이너의 실행 성공/실패 여부에 따라 Succeedd/Falied 단계로 이동
- 파드 안에서 쿠버네티스는 다양한 컨테이너 상태를 추적하고 파드를 다시 정상 상태로 만들기 위해 조치를 취함
- 파드가 노드에 할당되면 → 파드는 중지되거나 종료될 때 까지 해당 노드에서 실행

## 1. 파드의 수명

- 파드 생성 → 고유 UID 할당 → 노드에 스케줄 → 노드 종료 → 파드 삭제
- 쿠버네티스는 컨트롤러로 파드 인스턴스 관리
- UID가 할당된 파드는 다른 노드로 다시 스케줄 되지 않음
- 파드 삭제 → 파드에 할당된 볼륨 삭제→ 동일한 대체 파드가 생성 → 관련된 볼륨 새로 생성

## 2. 파드의 단계

- 파드의 status 필드는 phase 필드를 포함하는 PodStatus 오브젝트로 정의됨
    - phase → 파드가 라이프사이클 중 어느 단계에 해당하는지 표현
- phase의 값
    
    
    | 값 | 의미 |
    | --- | --- |
    | `Pending` | 파드가 쿠버네티스 클러스터에서 승인되었지만, 하나 이상의 컨테이너가 설정되지 않았고 실행할 준비가 되지 않았다. 여기에는 파드가 스케줄되기 이전까지의 시간 뿐만 아니라 네트워크를 통한 컨테이너 이미지 다운로드 시간도 포함된다. |
    | `Running` | 파드가 노드에 바인딩되었고, 모든 컨테이너가 생성되었다. 적어도 하나의 컨테이너가 아직 실행 중이거나, 시작 또는 재시작 중에 있다. |
    | `Succeeded` | 파드에 있는 모든 컨테이너들이 성공적으로 종료되었고, 재시작되지 않을 것이다. |
    | `Failed` | 파드에 있는 모든 컨테이너가 종료되었고, 적어도 하나 이상의 컨테이너가 실패로 종료되었다. 즉, 해당 컨테이너는 non-zero 상태로 빠져나왔거나(exited) 시스템에 의해서 종료(terminated)되었다. |
    | `Unknown` | 어떤 이유에 의해서 파드의 상태를 얻을 수 없다. 이 단계는 일반적으로 파드가 실행되어야 하는 노드와의 통신 오류로 인해 발생한다. |
- 노드가 죽거나 클러스터의 나머지와의 연결이 끊어지면 쿠버네티스는 손실된 노드의 모든 파드의 `phase` 를 Failed로 설정하는 정책을 적용

## 3. 컨테이너 상태

- 쿠버네티스는 파드 내부의 각 컨테이너 상태를 추적
- 컨테이너 라이프사이클 훅을 사용하여 컨테이너 라이프사이클의 특정 지점에서 실행할 이벤트를 트리거할 수 있음
- 스케줄러가 노드에 파드 할당 → kubelet는 컨테이너 런타임을 사용하여 해당 파드에 대한 컨테이너 생성 시작 → 표시될 수 있는 세 가지 컨테이너 상태:  `Waiting`, `Running` , `Terminated`
- Waiting
    - 시작을 완료하는데 필요한 작업을 계속 실행하고 있는 상태
    - 컨테이너 이미지 레지스트리에서 컨테이너 이미지 가져오기, 시크릿 데이터를 적용하기 등
- Running
    - 컨테이너가 문제없이 실행되고 있는 것
- Terminated
    - 실행 완료 상태 또는 실행 실패 상태
    - 컨테이너에 구성된 preStop 훅이 있는 경우 컨테이너가 Terminated 상태에 들어가기 전에 실행됨
