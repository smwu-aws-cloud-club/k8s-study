# 1. MSA vs Monolith 비교

# 🔎 모놀리식 아키텍쳐**(Monolithic Architecture, MA)**

## ✅ 모놀리식 아키텍쳐의 정의

**단순하고 간결하게, 하나의 앱으로** 

> 모놀리식 아키텍처는 하나의 통합된 코드 베이스로 여러 비즈니스 기능을 수행하는 전통적인 소프트웨어 개발 모델이다. **단일 애플리케이션 내에 서비스의 모든 로직이 통으로 들어가 있는 구조이다**.
>

다양한 서비스들이 단일 애플리케이션 안에 포함되어 있는 구조이며, 단일 DB와 연결해서 사용하고 보안, 설정등 모두 공통으로 사용하기 때문에 개발 속도가 빠르다.



## ✅ 모놀리식 아키텍쳐의 장점

- **구조가 간결함**

  모든 기능이 하나의 애플리케이션에 포함되어 있어 관리가 단순함.

- **엔드 투 엔드(E2E) 테스트 속도가 빠름**

  중앙 집중형 구조 덕분에 전체 흐름을 빠르게 테스트 가능.

- **디버깅이 쉬움**

  비즈니스 로직, UI, 콘텐츠 등 모든 코드가 한곳에 있어 추적이 간편함.

- **소규모 애플리케이션에 적합**

  단순하면서도 견고한 구조를 구현하기 유리함.


## ✅ 모놀리식 아키텍쳐의 단점

- **빌드 및 배포 시간 증가**

  애플리케이션 규모가 커질수록 구동, 빌드, 배포에 시간이 오래 걸림.

- **장애 전파 위험**

  하나의 컴포넌트 문제로 전체 시스템에 영향을 줄 수 있음.

- **배포 유연성 부족**

  작은 수정도 전체 애플리케이션을 다시 컴파일하고 배포해야 함.

- **기술 선택의 제약**

  모든 기능이 하나의 코드베이스에 있으므로, 기능별로 다른 기술 스택을 적용하기 어려움.


<br>
모놀리식 아키텍처는 기술적 복잡도가 낮은 소규모 프로젝트, MVP 수준의 단일 비즈니스 또는 신설 도메인 등 시장 진입을 위해 빠르고 간편하게 기능 개발 및 배포를 수행해야 할 때 적합하다.


# 🔎 마이크로 서비스 아키텍쳐(Microservices Architecture, MSA)

**쪼갤수록 더 명확해진다**

> 마이크로 서비스 아키텍쳐는 단일 애플리케이션으로 이루어진 모놀리식 아키텍처와 달리 서비스를 아주 작은 서비스*(Microservice)* 단위로 나눠 **각 서비스에서 독립적으로 서비스를 구성하는 모델**이다. 중앙 집중적인 관리 체계 대신 경량화된 API나 메시지로 직접 통신하며 접근하는 방식을 취하고 있다.
>

각 서비스는 도메인 별로 분리되어 있으며, 별도의 코드베이스 및 데이터 저장소를 갖추고 동작한다. 특정 서비스에만 자원을 집중할 수 있어, 전체 확장에 비해 효율적이다


## ✅ 모놀리식 아키텍쳐의 장점

- **개발 및 배포의 민첩성과 유연성**

  서비스를 잘게 나눠 독립적으로 개발·배포 가능 → 작업 시간 단축, 유지보수 용이.

- **빠르고 잦은 배포에 유리**

  애자일(Agile) 방식과 잘 맞고, 반복적인 개선이 쉬움.

- **장애 격리**

  한 서비스에 문제가 생겨도 다른 서비스는 정상적으로 작동함.

- **기술 스택의 다양성 확보**

  각 서비스에 적합한 언어나 프레임워크를 자유롭게 선택 가능.

- **독립적인 데이터 관리**

  서비스마다 자체 DB를 가짐 → 데이터 무결성 유지에 효과적.


## ✅ 모놀리식 아키텍쳐의 단점

- **통신 비용 및 지연 발생**

  서비스 간 API 호출로 네트워크 비용과 응답 지연 시간 증가.

- **인프라 비용 증가**

  각 서비스별로 독립된 환경을 운영해야 하므로 비용 부담이 큼.

- **디버깅 및 테스트 어려움**

  장애 원인 추적, E2E 테스트 등이 복잡해짐.

- **데이터 조회 및 관리의 어려움**

  DB 분리로 인해 데이터 통합 조회가 어렵고, 중복 가능성 존재.

- **복잡도 증가로 인한 관리 부담**

  서비스 수가 많아질수록 구조가 복잡해지고, 관리 실패 시 오히려 성능 저하 및 개발 지연 가능.

- **마이크로서비스 전환의 역효과 사례 존재**

  무분별한 분산은 오히려 비효율을 초래할 수 있음.


<br>

마이크로 서비스 아키텍처는 기술적 복잡도가 높은 대규모 프로젝트, 다양한 기술 스택을 사용하고, 여러 비즈니스별 요구사항이 명확한 경우, 장애를 줄이고 시스템 전체의 가용성과 탄력성을 높여야 할 때 적합하다.



# 🔎 모놀리식 아키텍처와 마이크로 서비스 아키텍처의 차이점

### ✅ **구조**

**모놀지식 아키텍처**는 단일 애플리케이션으로 기능을 통합한 구조로 이루어져 있다. 때문에 각 기능은 서로 강하게 의존할 수 있다.

**마이크로 서비스 아키텍처**는 독립적인 서비스로 애플리케이션을 나누어 구성한다. 각 서비스는 API를 통해 통신하며, 분산 시스템을 형성하게 된다.

### ✅ **배포**

**모놀리식 아키텍처는** 전체 애플리케이션을 한 번에 배포해야 한다. 한 부분만 변경해도 전체 애플리케이션을 배포해야 한다.

**마이크로 서비스 아키텍처는** 각 서비스를 독립적으로 개발, 테스트, 배포되며 이는 애플리케이션 전체를 다시 배포하지 않고도 개별 서비스를 업데이트 할 수 있다는 것을 의미한다.

### ✅ **기술의 다양성**

**모놀리식 아키텍처는** 애플리케이션 전체에 동일한 기술 스택을 사용해야 한다.

**마이크로 서비스 아키텍처는** 각 서비스마다 자체적인 기술 스택을 선택할 수 있다.

### ✅ **유연성**

**모놀리식 아키텍처는** 애플리케이션 확장이 필요한 경우, 전체를 확장해야 하므로 특정 부분의 수요가 증가하더라도 전체 애플리케이션을 확장해야한다.

**마이크로 서비스 아키텍처는** 특정 서비스에 대한 수요가 증가하면 해당 서비스만 확장할 수 있어 자원을 효율적으로 사용할 수 있다.

### ✅ **지연 시간**

**모놀리식 아키텍처는** 모든 서비스가 단일 코드 베이스에 존재하기 때문에 네트워크 대기시간이 발생하지 않는다.

**마이크로 서비스 아키텍처**는 다른 서비스와 통신을 해야하기 때문에 네트워크 대기시간이 발생할 수 있다. 이때문에 모놀리식 아키텍처와 비교하여 성능이 더 느리다.

<aside>
💡

마이크로서비스 아키텍처와 모놀리식 아키텍처는 서로 다른 특성과 장점을 가지고 있다. 때문에 아키텍처를 선택할 때는 **프로젝트의 규모나 팀의 여건, 비즈니스 요구사항 등 여러 요인을 고려**해야 한다. 해당 비즈니스에 가장 적절한 아키텍처가 무엇인지 판단하고 적용하는 게 가장 중요하다.

</aside>

## 참고자료

https://www.inflearn.com/pages/infcon-2023-tech-msa?gad_source=1&gad_campaignid=20714471420&gbraid=0AAAAADAClSAHCP7HSOtW-rpG_81mP_yL4&gclid=CjwKCAjw4efDBhATEiwAaDBpbiF3ELBLNIt_lHz87SKLExKwZApUD7gq7GOMEQgG6ESzTyU8YlKXxRoCz5MQAvD_BwE

https://memodayoungee.tistory.com/155

<br>

<hr>

# 2. Spring MVC vs Spring cloud msa

# 🔎 Spring MVC

## ✅ Spring MVC의 정의

> MVC란 **Model, View, Controller**를 의미하며, 소프트웨어 디자인 패턴의 일종
Spring MVC는 MVC 패턴을 **Spring framework 내**에서 쉽게 구현할 수 있도록 여러 가지 기능을 제공하고 있는 것이다.
>

## ✅ Spring MVC의 구성요소

- **Model**
    - 객체를 통해 표현하며 View에 전달하기 위해 Model 객체에 필요한 데이터를 저장하여 전달
    - 비즈니스 로직은 클래스 레벨에 @Service 어노테이션을 추가하여 구현
    - JSON으로 반환하는 경우에는 View에 전달하지 않고 객체를 JSON 포맷으로 변환하여 HTTP body에 넣어 반환
- **View**
    - 정적인 HTML을 반환하거나 템플릿 엔진을 통해 동적인 HTML을 만들어 반환하는 등의 동작
    - 템플릿 엔진으로는 JSP, Thymeleaf, Freemarker, Velocity 등이 존재
- **Controller**
    - 클래스 레벨에 @Controller 또는 @RestController 어노테이션을 추가하여 구현
    - @Controller의 경우 메서드 반환값을 ViewResolver에 전달하여 해당 View를 찾아서 반환
    - @RestController의 경우 메서드 반환값을 HttpMessageConverter에 전달하여 알맞게 변환 후 HTTP body에 담아서 반환

# 🔎 Spring cloud msa

## ✅ Spring cloud msa의 정의

> Spring cloud msa란 **Spring Boot 기반의 독립적이고 경량화된 마이크로서비스**들을 구성하고, 이들 사이의 **통신, 라우팅, 로드밸런싱, 구성 관리, 서비스 디스커버리, 장애 복구** 등의 기능을 **Spring Cloud**를 통해 중앙 관리하거나 자동화하는 아키텍처이다.
>

## ✅ Spring cloud msa의 구성요소

- **Spring Cloud API Gateway**
    - 마이크로서비스 아키텍처에서 Gateway로서 클라이언트의 단일 진입점 역할을 하는 서버 역할을 한다.
    - 인증, 권한 부여, 로드 밸런싱, 라우팅, 트래픽 제어 등의 기능을 제공한다.
    - 클라이언트는 API Gateway를 통해 여러 서비스에 대한 요청을 보내고, API Gateway는 이를 해당 서비스로 라우팅해준다.
- **Spring Cloud Config Server**
    - 설정 관리를 중앙에서 효과적으로 관리할 수 있게 해주는 서버 역할을 한다.
    - 각 마이크로서비스는 Config Server를 통해 자체적인 설정을 동적으로 가져올 수 있으며 설정의 중앙 집중 관리로 유지보수 및 변경 관리를 용이하게 한다.
- **Spring Service Registry (Naming Server)**
    - MSA에서서비스 인스턴스의 등록과 검색을 담당하는 서버 역할을 한다.
    - 서비스 인스턴스의 등록과 해제를 관리하며 서비스 디스커버리를 통해 클라이언트는 특정 서비스 인스턴스를 동적으로 찾을 수 있다.
    - 대표적인 예로는 Netflix Eureka
- **Distributed Tracing**
    - 마이크로서비스 아키텍처에서 여러 서비스 간의 트랜잭션을 추적하고 모니터링하는 기술
    - 대표적인 도구로는 Zipkin이나 Jaeger

# 🔎 Spring MVC와 Spring Cloud MSA 차이점

### ✅아키텍처 구조

- Spring MVC는 단일(모놀리식) 프로젝트 구조로, 모든 기능·로직이 한 코드베이스에 존재함
- Spring Cloud MSA는 서비스별로 독립된 프로젝트로 나누어, 여러 마이크로서비스 형식으로 구성함

### ✅배포 및 빌드 방식

- Spring MVC는 전체를 한 번에 빌드·패키징하고, 배포 시 전체를 교체함
- Spring Cloud MSA는 필요한 개별 서비스만 별도로 빌드·배포 가능함

### ✅확장성

- Spring MVC는 특정 기능만 트래픽이 늘어나도 전체 시스템을 같이 확장해야 함
- Spring Cloud MSA는 트래픽이 몰리는 서비스만 따로 확장 가능하여 리소스 활용 효율적임

### ✅장애 격리

- Spring MVC는 한 기능의 장애가 전체 서버 다운으로 이어질 수 있음
- Spring Cloud MSA는 특정 서비스 장애 시 그 서비스만 영향, 나머지는 정상 운영됨

### ✅기술 스택 자유도

- Spring MVC는 프로젝트 전체에 동일 언어·프레임워크만 사용 가능함
- Spring Cloud MSA는 각 서비스마다 다른 언어, 프레임워크, 데이터베이스 자유롭게 선택 가능

### ✅팀/운영 관리

- Spring MVC는 관리 및 모니터링, 배포가 상대적으로 단순하나, 서비스가 커질수록 코드 충돌·협업 난이도↑
- Spring Cloud MSA는 서비스·인프라 수가 많아 운용이 복잡하며, 자동화/모니터링 도구 필요


<br>

Spring MVC는 소규모 팀이나 초기 MVP, 복잡하지 않은 서비스에 적합하고, Spring Cloud MSA는 대규모 서비스, 잦은 변경·확장, 다수의 독립적 개발팀이 존재할 때 적합하다.


## 참고자료

https://injae-dev.tistory.com/entry/Spring-MVC-%EA%B0%84%EB%8B%A8-%EC%A0%95%EB%A6%AC

https://sjh9708.tistory.com/119


<br>
<hr>

# 3. spring cloud msa 구성 요소 및 설계 방식 이해

> Spring Cloud MSA의 대표적인 구성요소(API Gateway, Config Server, Eureka)는 서비스의 통신, 설정, 진입점 등 마이크로서비스 환경에서 반드시 필요한 인프라적 역할을 담당한다.
>

# 🔎 API Gateway

## ✅ 개념 및 정의

- **API Gateway**는 모든 클라이언트 요청이 가장 먼저 도달하는 단일 진입점(Front Door)이다.
- 다양한 클라이언트(웹, 모바일 등)의 요청을 적절한 백엔드 마이크로서비스에 분배하는 중간 역할을 수행한다.

## ✅ 주요 역할 및 기능

- **요청 라우팅**: 클라이언트의 URI, HTTP 메서드 등에 따라 내부 마이크로서비스로 요청을 전달

  예시: **`/api/v1/users/**`** → USER-SERVICE로 전달

- **인증/인가 처리**: JWT 인증, API Key 체크 등 보안 기능을 한 곳에서 담당
- **Pre/Post 필터링**: 모든 요청/응답에 대해 공통적으로 헤더 추가, 로깅, 추적 ID 삽입 등 가능
- **CORS, HTTPS, Rate Limiting**: 웹 보안 및 성능 관련 정책을 집중 관리
- **로드 밸런싱**: 서비스 인스턴스 여러 개가 있을 때 트래픽을 자동 분산

## ✅ 필요성

- 각 마이크로서비스의 세부 주소를 클라이언트가 몰라도 됨
- 인증, 로깅, 보안 정책을 한 곳에서 일관성 있게 처리 → 서비스별 코드 중복 방지
- 서비스가 수십 개로 늘어나도 진입점은 하나로 통일
- 마이크로서비스마다 프론트엔드 전환 필요 없이, BFF(Backend For Frontend) 패턴도 구현 가능

# 🔎 Config Server

## ✅ 개념 및 정의

- **Config Server**는 모든 마이크로서비스의 설정파일을 중앙에서 관리하는 서버이다.
- 보통 Git 저장소에서 설정 파일을 읽어와 각 서비스에 배포한다.

## ✅ 주요 역할 및 기능

- **설정 중앙화**: 각 마이크로서비스가 자체적으로 관리하지 않고, 한 곳에서 통합 관리

  (예: **`application-member.yml`**, **`application-order.yml`** 등을 한 Git에 저장)

- **환경별 관리**: 개발, 테스트, 운영 등 환경별로 설정파일을 분리해 효율 관리

  (예: **`application-dev.yml`**, **`application-prod.yml`**)

- **변경 실시간 반영**: Spring Cloud Bus 연동 시 설정 변경사항을 실시간으로 서비스에 반영 가능
- **보안 정보 관리**: DB 패스워드, API KEY 등 민감 정보도 외부 저장소에 안전하게 관리
- **버전 관리 및 롤백**: Git 기반으로 설정 변경 이력, 버전 추적, 롤백 가능

## ✅ 필요성

- 서비스가 많아질수록 환경변수, 인증 정보 등 일일이 개별 관리가 불가능
- 설정 수정을 위해 매번 재배포 없이, 중앙에서 한 번에 변경 가능
- 다양한 환경(운영, QA, dev)에 맞는 세밀한 설정 분리·배포가 용이

# 🔎 Eureka (Service Discovery)

## ✅ 개념 및 정의

- **Eureka**는 각 마이크로서비스의 위치(IP, Port 등)를 기록·조회하는 네이밍 서버(서비스 레지스트리)이다.
- 각 서비스 인스턴스는 Eureka에 자신을 등록(register)하며, 다른 서비스들은 이를 검색(discovery)해서 동적으로 호출한다

## ✅ **역할**

- **서비스 등록**: 서비스가 실행될 때 자신의 위치정보(IP, Port 등)를 Eureka에 등록
- **서비스 탐색**: 통신이 필요한 마이크로서비스가 Eureka로부터 상대방의 정보(IP/Port 리스트)를 조회

  (예: Order 서비스가 User 서비스 위치를 매번 물어보고 호출)

- **헬스체크/자동 제거**: 서비스의 상태(Health)를 주기적으로 체크 후, 죽은 인스턴스는 자동 제외
- **동적 라우팅/로드밸런싱**: 인스턴스 IP, Port가 바뀌어도 무관하게 라우팅/트래픽 분배 가능
- **무중단 확장/축소**: 새로운 인스턴스 추가, 장애 인스턴스 제거 시 서비스 중단 없이 반영

## ✅ 필요성

- 클라우드 환경에서 서비스의 IP와 Port가 동적으로 바뀌는 상황에 대응
- 고정 주소 없이도, “서비스 이름”으로 탐색해 통신 → 민첩한 인프라 운영
- 자동 장애 조치, 트래픽 분산 등 대규모 서비스 운영에 필수

# 🔎 전체 흐름 예시

1. **클라이언트**가 API Gateway에 HTTP 요청 전송
2. Gateway는 라우팅 규칙에 따라 Eureka에서 현재 가용 중인 마이크로서비스 인스턴스 목록을 조회
3. 적합한 인스턴스를 선정해 요청을 전달하며, 인증·필터 등 공통 처리를 수행
4. 각 서비스는 Config Server에서 실시간으로 설정파일을 가져와 구동
5. 각 서비스끼리 내부 통신 시에도 서비스 이름 기반(Eureka 활용)으로 위치 탐색 및 호출

| **구성요소** | **대표 기능** | **구체적 역할 및 이유** |
| --- | --- | --- |
| **API Gateway** | 중앙 진입점 | 모든 트래픽 통합 처리, 인증/보안, 로깅, 라우팅, 다양한 프론트엔드 대응 |
| **Config Server** | 설정 중앙화/자동배포 | 환경별 설정분리, 실시간 변동 반영, 보안·버전 관리 |
| **Eureka** | 서비스 위치등록·탐색 | IP 변동 대응, 각 서비스의 네이밍/동적 연결, 서비스 장애 조기 발견 |

## 참고자료

https://dongker.tistory.com/entry/Spring-Cloud-MSA-Config-Gateway-Eureka%EA%B9%8C%EC%A7%80-MSA-%ED%95%B5%EC%8B%AC-%EA%B5%AC%EC%A1%B0-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0