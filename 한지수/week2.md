# 파드 & 파드 라이프사이클

# 1. 파드

파드(Pod)는 쿠버네티스에서 관리할 수 있는 가장 작은 단위로, 하나 이상의 컨테이너로 구성된 그룹이다. 파드에 속한 컨테이너들은 저장공간(스토리지)과 네트워크를 함께 사용하며, 같이 실행되도록 설정된다.

파드는 하나의 애플리케이션이 실행되는 “논리 호스트”처럼 작동하며, 클라우드 환경에서는 여러 컨테이너가 같은 파드에서 함께 실행될 수 있다. 이는 일반적인 서버에서 여러 프로그램이 동시에 돌아가는 것과 비슷하다.

파드에는 일반적인 애플리케이션 컨테이너 외에도, 파드가 시작될 때 필요한 초기 설정을 담당하는 초기화 컨테이너가 있을 수 있다. 또한 문제가 발생했을 때 디버깅을 위해 임시 컨테이너를 추가할 수도 있다.

### 파드란 무엇인가?

파드의 공유 콘텍스트는 리눅스 네임 스페이스, 컨트롤 그룹, 그리고 컨테이너 격리 요소와 같은 다양한 격리 메커니즘으로 구성된다. 파드 내에서는 이러한 공유 컨텍스트를 기반으로 개별 애플리케이션에 추가적인 하위 격리 요소가 적용된다.

### 파드의 사용

파드는 쿠버네티스에서 **nginx:1.14.2** 이미지를 실행하는 컨테이너로 구성될 수 있다. 예를 들어 다음과 같은 설정으로 파드를 만들 수 있다.

```yaml
apiVersion: v1  
kind: Pod  
metadata:  
  name: nginx  
spec:  
  containers:  
  - name: nginx  
    image: nginx:1.14.2  
    ports:  
    - containerPort: 80  
```

이 파드는 다음 명령어로 생성할 수 있다.

```bash
kubectl apply -f https://k8s.io/examples/pods/simple-pod.yaml
```

- **Workload resources for managing pods [](https://kubernetes.io/ko/docs/concepts/workloads/pods/#workload-resources-for-managing-pods)**

보통은 파드를 직접 생성하지 않고, 디플로이먼트(Deployment)나 잡(job)같은 워크로드 리소스를 통해 생성하는 것이 일반적이다. 만약 파드가 데이터를 저장하는 등 상태를 유지해야 한다면 스테이트풀셋(StatefulSet)을 사용한다.

쿠버네티스 클러스터의 파드는 두 가지 주요 방식으로 사용된다.

1. **단일 컨테이너 파드**

   가장 일반적인 형태이며 하나의 컨테이너만을 포함한다

   쿠버네티스는 개별 컨테이너가 아닌 파드단위로 관리한다


1. **다중 컨테이너 파드**

   함께 동작해야 하는 여러 컨테이너를 한 파드에 넣을 수 있다

   예를 들어, 한 컨테이너는 데이터를 제공하고, 다른 컨테이너는 해당 데이터를 주기적으로 업데이트하는 구조가 가능하다.


파드는 기본적으로 애플리케이션의 한 인스턴스를 실행하는 구조이다. 따라서 여러 인스턴스를 배포해 서비스 규모를 키우려면 각 인스턴스를 별도의 파드로 배포해야 한다. 이 방식을 레플리케이션(Replication)이라고 하며, 보통 워크로드 리소스와 해당 컨트롤러가 관리한다.

- **파드가 여러 컨테이너를 관리하는 방법**

파드는 여러 개의 협력하는 컨테이너들을 하나의 단위로 묶어 관리하는 Kubernetes의 기본적인 실행단위이다. 파드에 속한 컨테이너들은 같은 서버에서 함께 배치되고, 서로 리소스(네트워킹, 스토리지)를 공유한다.

즉 파드는 같은 목적을 가진 컨테이너들이 하나의 그룹으로 묶여 협력하는 구조이다. 예를들어 웹 서버를 담당하는 컨테이너와, 웹 서버 파일을 업데이터하는 “사이드카”컨테이너가 같은 파드에 있을 수 잇다.

초기화 컨테이너도 있을 수 있는데, 이는 앱 컨테이너가 시작되기 전에 실행되어 필요한 작업을 마친 후 종료된다.

### 파드 작업

일반적으로 일회용으로 설계되어, 사용자가 직접 만들기보다는 컨트롤러에 의해 자동으로 생성된다. 파드가 생성되면, 클러스터의 노드에서 실행되며, 실행이 완료되거나 삭제되거나 리소스 부족 등으로 종료될 때까지 해당 노드에서 유지된다.

파드는 컨테이너를 실행하는 환경으로, 컨테이너가 실패하면 재시작되지만, 파드는 그대로 유지된다. 즉, 파드를 삭제하기 전까지는 계속 존재한다. 또한 파드 이름은 유효한 DNS 서브도메인 이름이어야 하며, 이를 통해 파드가 네트워크에서 정확히 식별된다.

- **파드 OS**

  파드를 실행할 때 운영체제를 지정할 수 잇다. 현재 쿠버네티스에서 지원하는 운영체제는 Linux와 Windows이다.


- **파드와 컨트롤러**

  사용자는 일반적으로 개별 파드를 직접 생성하지 않는다. 대신 컨트롤러가 여러 파드를 자동으로 관리한다. 컨트롤러는 파드의 실패를 감지하고, 대체 파드를 생성하거나 롤백하여 시스템의 안정성을 유지한다. 예를 들어, 노드가 실패하면 컨트롤러가 해당 노드의 파드를 새 노드로 재배치한다.

  하나 이상의 파드를 관리하는 워크로드 리소스의 예시는 다음과 같다.

    - **디플로이먼트**
    - **스테이트풀셋**
    - **데몬셋**

- **파드 템플릿**

  파드 템플릿은 파드를 생성하기위한 매니페스트로, 워크로드 리소스(예: Deployment, Job 등)에 포함된다. 이 템플릿을 사용하여 컨트롤러는 실제 파드를 생성하고 관리한다. 파드 템플릿을 수정하면, 기존 파드에는 영향을 주지 않으며, 컨트롤러는 새로운 템플릿을 바탕으로 새로운 파드를 생성한다.

    ```yaml
    apiVersion: batch/v1
    kind: Job
    metadata:
      name: hello
    spec:
      template:
        # 여기서부터 파드 템플릿이다
        spec:
          containers:
          - name: hello
            image: busybox:1.28
            command: ['sh', '-c', 'echo "Hello, Kubernetes!" && sleep 3600']
          restartPolicy: OnFailure
        # 여기까지 파드 템플릿이다
    ```

  해당 YAML 파일에 있는 예시는 Job 리소스에 대한 파드 템플릿을 설명하는 예시이다. 이 YAML은 배치 작업을 수행하는 Job을 정의하고 있으며, 하나의 컨테이너가 실행되는 파드 템플릿을 포함하고 있다.

  ### 파드 갱신 및 교체

  워크로드 리소스의 파드 템플릿이 변경되면, 쿠버네티스는 기존 파드를 수정하거나 업데이트하는 대신, 변경된 템플릿을 기반으로 새로운 파드를 생성한다.

  쿠버네티스는 사용자가 파드를 직접 관리하는 것을 막지 않으며, 실행 중인 파드의 필드를 갱신하는 것도 가능하다. 하지만 파드를 갱신하는 작업(예: 패치 또는 교체)에는 몇 가지 제한이 있다.

    - 파드 메타데이터 수정 불가: `namespace`, `name`, `uid`, `creationTimestamp` 등의 필드는 수정할 수 없다.
    - `generation` 필드: `generation` 필드는 값이 증가하는 갱신만 허용된다.
    - `metadata.deletionTimestamp` 설정:  `metadata.finalizers` 리스트에 새로운 항목을 추가할 수 없다.
    - `spec` 필드 수정 제한: `spec.containers[*].image`, `spec.initContainers[*].image`, `spec.activeDeadlineSeconds`, `spec.tolerations` 외에는 변경할 수 없다.
    - `spec.activeDeadlineSeconds` 갱신 제한: 이 필드는 양수로 설정하거나, 더 작은 양수로 갱신할 수 있다.
    - `spec.tolerations` 갱신 제한: 새로운 항목만 추가할 수 있다.

### 리소스 공유와 통신

파드는 파드에 속한 컨테이너 간의 데이터 공유와 통신을 지원한다.

- **파드 스토리지**

  파드는 여러 컨테이너들이 공유할 수 있는 볼륨을 지정할 수 있다. 이를 통해 파드 내의 모든 컨테이너는 데이터를 공유할 수 있다. 또한 볼륨을 사용하면 파드 내의 일부 컨테이너가 다시 시작되더라도 데이터를 영구적으로 유지할 수 있다.


- **파드 네트워킹**

  각 파드는 고유한 IP 주소를 할당받고, 파드 내의 모든 컨테이너는 네트워크 네임스페이스를 공유한다. 이를 통해 파드 내의 컨테이너는 localhost를 사용하여 서로 쉽게 통신할 수 있다. 파드 외부와의 통신은 네트워크 리소스를 조장하여 이루어져야 한다.

  파드 내의 컨테이너는 표준 프로세스 간 통신(예: SystemV 세마포어나 POSIX 공유 메모리)을 사용할 수 있다. 그러나 다른 파드의 컨테이너와는 고유한 IP를 가지므로, 별도의 설정없이 OS 수준에서 통신할 수 없다. 다른 파드의 컨테이너와 통신하려면 IP 네트워킹을 사용해야 한다.

  또한 파드 내의 모든 컨테이너는 동일한 시스템 호스트명으로 간주한다.


### 컨테이너에 대한 특권 모드

리눅스에서 파드 내의 모든 컨테이너는 보안 설정에서 `priviledged` 플래그를 사용하여 특권모드를 활성화할 수 있다. 이 모드는 네트워크나 하드웨어 장치에 접근하거나 운영체제의 관리 기능을 사용해야 하는 컨테이너에 유용하다.

만약 클러스터에서 WindowsHostProcessContainers 기능을 활성화했다면, 파드의 보안 설정에서 `windowsOptions.hostProcess` 를 통해 윈도우 HostProcess 파드를 생성할 수 있다. 이 파드는 윈도우에서 직접 실행되며, 리눅스의 특권모드와 유사한 관리작업을 수행할 수 있다. 이 경우, 파드 내의 모든 컨테이너는 반드시 윈도우 HostProcess 컨테이너로 실행되어야 한다.

### 정적 파트

정적파트는 Kubelet이 직접 관리하는 파트이다. 일반적인 파드는 API 서버에서 관리하지만, 정적 파드는 Kublet이 파드를 직접 책임지고 실패하면 다시 시작한다. 주로 자체 컨트롤 플레인을 운영할 때 사용된다.

정적 파드는 특정 노드에만 연결되고, 그 노드에서만 관리된다. 그리고 kubelet은 자동으로 API 서버에서 볼 수 있게 한다. 다만, API 서버에서는 이 파드를 직접 제어할 수 없다.

### 컨테이너 프로브

컨테이너 프로브는 kublet이 컨테이너의 상태를 주기적으로 점검하는 과정이다. 이때 kublet은 다음 방법들을 사용해 상태를 확인한다.

- **ExecAction**: 컨테이너 내부에서 명령을 실행해 확인.
- **TCPSocketAction**: 컨테이너의 포트를 통해 네트워크 연결을 검사.
- **HTTPGetAction**: 컨테이너에서 HTTP 요청을 보내 상태를 확인.

---

# 2. **파드 라이프사이클**

파드 라이프사이클은 여러 단계로 이루어져있다. 처음에는 Pending 단계에서 시작되며, 파드 내의 컨테이너 중 하나 이상이 정상적으로 시작되면 Running 단계로 넘어간다. 그 후, 컨테이너가 실패하면 Failed 상태로, 성공적으로 종료되면 Succeeded 상태로 이동한다.

파드가 실행되는 동안, kubelet은 오류가 발생하면 컨테이너를 다시 시작할 수 있다. 쿠버네티스는 파드 내의 여러 컨테이너 상태를 추적하고, 문제가 있으면 이를 해결하려고 한다.

파드는 한 번만 스케줄링되어 노드에 배치되고, 종료될 때까지 그 노드에서 실행된다. 또한 파드는 명세와 실제상태를 가지고 있으며, 필요한 경우 파드 상태에 추가 정보를 삽입할 수도 있다.

### 파드의 수명

파드는 임시적인 존재로, 애플리케이션의 실행단위인 개별 컨테이너와 비슷하다. 파드가 생성되면 고유한 ID가 생성되고, 노드에 배치된다. 파드가 종료되거나 삭제될 때까지 해당 노드에서 실행된다. 만약 노드가 종료되면, 그 노드에 있던 파드는 일정 시간이 지나면 자동으로 삭제된다.

파드는 자가 치유되지 않아서, 노드가 실패하면 그에 배치된 파드는 삭제된다. 리소스 부족이나 노드 유지보수로 인해 파드가 축출되면 그 파드는 살아남지 못한다. 쿠버네티스는 이런 파드를 관리하기 위해 컨트롤러를 사용하여 새로운 파드를 생성하거나 대체한다.

파드는 고유 ID(UID)를 가지고 있기 때문에, 한 번 배치된 파드는 다른 노드로 재배치되지 않는다. 대신 UID가 다른 새로운 파드로 대체될 수 있다. 볼륨과 같은 리소스는 파드와 동일한 수명을 가지며, 파드가 삭제되면 그에 관련된 리소스도 새로 생성된다.

Pod diagram은 여러 컨테이너가 함께 공유하는 스토리지를 사용하는 예시로, 웹 서버와 파일을 가져오는 풀러(puller)가 포함된 파드의 구조를 보여준다.

### 파드의 단계

파드의 상태는 Phase 라는 필드로 나타내며, 이는 파드가 라이프사이클 중 어느 단계에 있는지 알려준다. 파드의 Phase 값은 고유하며, 각 값은 특정 상태를 나타낸다.

- Pending : 파드가 승인되었지만, 아직 실행 준비가 되지 않은 상태
- Runniung:  파드가 노드에 바인딩되고, 적어도 하나의 컨테이너가 실행 중인 상태
- Succeeded: 모든 컨테이너가 성공적으로 종료된 상태
- Failed : 하나 이상의 컨테이너가 실패하여 종료된 상태
- Unknown : 파드의 상태를 알 수 없는 상태

Terminating은 파드가 삭제 중일 때 표시되며, Phase 값에 포함되지 않는다. 파든 기본적으로 30초 동안 그레이스 풀 종료 후 삭제되며, 강제로 종료하려면 —force 플래그를 사용한다.

### 컨테이너 상태

컨테이너는 Waiting, Runniung, Terminated 세 가지 상태로 나뉜다.

- Waiting : 컨테이너가 아직 시작되지 않았거나, 시작을 위한 작업이 진행 중인 상태. 이유는 kubectl desscrube pod 로 확인할 수 있다.
- Running : 컨테이너가 문제 없이 실행 중인 상태. postStart 훅이 있다면, 이미 실행된 상태일 수도 있다.
- Terminated : 컨테이너가 실행을 완료했거나 실패한 상태. 종료 이유와 코드, 실행 시간을 kubectl describe pod로 확인할 수 있다. 만약 preStop 훅이 있다면, Terminated 상테로 진입하기 전에 실행된다.

### 컨테이너 재시작 정책

파드의 `restartPolicy`는 파드의 컨테이너 재시작 조건을 설정하는 필드이다. 가능한 값은 **Always**, **OnFailure**, **Never**이며, 기본값은 **Always**이다.

- **Always**: 컨테이너가 종료되면 항상 재시작된다.
- **OnFailure**: 컨테이너가 오류로 종료되었을 때만 재시작된다.
- **Never**: 컨테이너가 종료되어도 재시작되지 않는다.

`restartPolicy`는 모든 컨테이너에 적용되며, **kubelet**에 의해 동일한 노드에서만 재시작된다. 재시작은 지수 백오프 방식(10초, 20초, 40초 등)으로 5분까지 지연되며, 10분 동안 정상적으로 실행되면 재시작 타이머가 초기화된다.

### 파드의 컨디션

파드는 하나의 `PodStatus`를 가지며, 그 안에는 파드가 통과한 또는 통과하지 못한 여러 `PodConditions` 배열이 있다. 각 `PodCondition`은 파드의 상태를 나타내며, kubelet은 다음과 같은 조건들을 관리한다:

1. **PodScheduled**: 파드가 노드에 스케줄되었는지 여부.
2. **PodHasNetwork**: 샌드박스가 성공적으로 생성되고 네트워크 구성이 완료되었는지 여부 (알파 기능).
3. **ContainersReady**: 파드 내 모든 컨테이너가 준비되었는지 여부.
4. **Initialized**: 모든 초기화 컨테이너가 성공적으로 완료되었는지 여부.
5. **Ready**: 파드가 요청을 처리할 준비가 되어 있으며, 해당 서비스의 로드 밸런싱 풀에 추가될 수 있는지 여부.

각 컨디션의 필드는 다음과 같다:

- **type**: 파드 컨디션의 이름.
- **status**: "True", "False", 또는 "Unknown" 값으로 해당 컨디션이 적용 가능한지 여부.
- **lastProbeTime**: 파드 컨디션이 마지막으로 확인된 시간.
- **lastTransitionTime**: 파드 상태가 변경된 마지막 시간.
- **reason**: 상태 변경 이유 (기계가 읽을 수 있는 UpperCamelCase 텍스트).
- **message**: 상태 변경에 대한 사람에게 읽을 수 있는 설명.

### 파드의 준비성

애플리케이션은 파드의 준비성 상태에 대한 추가적인 피드백이나 신호를 주입할 수 있다.  readinessGate 에 지정된 조건이 모두 True여야만 파드가 준비된 상태로 평가되며, 조건이 누락되거나 False일 경우 파드는 준비되지 않은 상태로 간주된다.

```yaml
kind: Pod
spec:
  readinessGates:
    - conditionType: "www.example.com/feature-1"
status:
  conditions:
    - type: Ready
      status: "False"
    - type: "www.example.com/feature-1"
      status: "False"
```

- 파드 준비성 상태

  `kubectl patch` 명령어는 파드 상태 패치를 지원하지 않으며, **status.conditions** 설정은 애플리케이션과 오퍼레이터의 **PATCH** 액션이 필요하다. 쿠버네티스 클라이언트 라이브러리를 사용하여 사용자 지정 파드 상태를 설정할 수 있다.

  파드 준비성 평가 조건은 다음과 같다.

    - 파드 내 모든 컨테이너가 준비 상태
    - **readinessGates**에 지정된 모든 컨디션이 **True**

  하나라도 **False**이거나 누락되면, **kubelet**은 파드 상태를 **ContainerReady**로 설정한다.


- 파드 네트워크 준비성

  파드가 노드에 스케줄링되면, kubelet이 파드를 승인하고 네트워킹을 구성한다. **PodHasNetworkCondition** 기능 게이트가 활성화되면, kubelet은 파드의 네트워크 초기화 상태를 **PodHasNetwork** 컨디션으로 보고한다.

    - 파드에 네트워크가 구성되지 않으면 **PodHasNetwork**는 **False**로 설정된다.
    - **PodHasNetwork**가 **True**로 설정되면 kubelet은 컨테이너를 생성할 수 있다.
    - 초기화 컨테이너가 있으면, kubelet은 초기화가 완료되면 **Initialized**를 **True**로 설정한다.
    - 초기화 컨테이너가 없으면, kubelet은 네트워크 구성이 시작되기 전에 **Initialized**를 **True**로 설정한다.

### 컨테이너 프로브

프로브는 kubelet이 주기적으로 컨테이너의 상태를 진단하기 위한 방법이다. 진단은 컨테이너 내에서 명령어를 실행하거나 네트워크 요청을 통해 수행된다.

- **체크 메커니즘:**
1. **exec**: 컨테이너 내에서 명령어 실행. 종료 코드가 0이면 성공.
2. **grpc**: gRPC로 원격 프로시저 호출. 응답 상태가 `SERVING`이면 성공. (알파 기능)
3. **httpGet**: 지정된 포트와 경로에서 HTTP GET 요청. 상태 코드가 200~399이면 성공.
4. **tcpSocket**: 지정된 포트에서 TCP 검사. 연결이 성공하면 성공.

- **프로브 결과:**
    - **Success**: 진단 통과
    - **Failure**: 진단 실패
    - **Unknown**: 진단 실패 (추가 확인 필요)

- **프로브 종류**
1. **livenessProbe**: 컨테이너가 동작 중인지 확인. 실패 시 컨테이너 재시작.
2. **readinessProbe**: 컨테이너가 요청을 처리할 준비가 되었는지 확인. 실패 시 서비스에서 파드 IP 제외.
3. **startupProbe**: 애플리케이션이 시작되었는지 확인. 실패 시 컨테이너 재시작.

- **사용 시기**
    - **활성 프로브**: 컨테이너가 건강하지 않으면 재시작을 원할 때 사용.
    - **준비성 프로브**: 컨테이너가 준비된 후에만 트래픽을 받도록 설정.
    - **스타트업 프로브**: 시작이 느린 애플리케이션을 위한 프로브.

- **참고 사항**
    - 파드가 삭제될 때 준비성 프로브가 없어도 파드는 자동으로 준비되지 않은 상태로 변경된다.
    - 스타트업 프로브는 긴 초기화 시간이 필요한 애플리케이션에 유용하다.

### 파드의 종료

- **파드 종료 흐름:**

  파드는 클러스터의 노드에서 실행되는 프로세스를 나타내며, 더 이상 필요하지 않을 때 정상적으로 종료되도록 해야 한다. 갑자기 종료되면 정리할 기회가 없으므로 유예 기간을 설정하여 정상적으로 종료되도록 한다.

    - **유예 기간**: 사용자가 파드 삭제를 요청하면, 유예 기간을 설정하여 파드가 정상적으로 종료될 수 있도록 한다. 유예 기간이 만료되면 강제로 종료되며, 이때 `KILL` 시그널이 전달된다.
    - **파드 종료 예시**:
        - `kubectl`을 사용하여 파드를 삭제하면, 파드는 "Terminating" 상태로 표시된다. `kubelet`은 정상 종료를 시도한다.
        - 파드의 컨테이너에 `preStop` 훅이 정의된 경우, 이를 실행하고 유예 기간을 연장할 수 있다.
        - 유예 기간이 만료되면, `SIGKILL` 시그널을 모든 컨테이너에 보내어 강제 종료된다.
        - 파드 삭제가 완료되면, 클러스터에서 해당 파드를 더 이상 사용할 수 없다.

    
- **강제 종료 및 삭제**
    - **강제 종료**: `-grace-period=0`과 `-force` 플래그를 사용하면 유예 기간을 0으로 설정하여 즉시 종료되도록 한다. 이때, `kubelet`은 즉시 종료 절차를 시작한다. 이 방법은 클러스터에서 자원이 정상적으로 종료되지 않을 수 있기 때문에 사용된다.
    - 즉시 종료: 파드가 실행 중인 자원에서 정상적으로 종료되지 않음을 보장하지 않으며, 자원이 회수되지 않을 수 있다.


- **파드 가비지 콜렉션 (PodGC)**:

  **PodGC**는 종료된 파드를 정리하여 리소스 유출을 방지한다. 종료된 파드가 `Succeeded` 또는 `Failed` 상태로 남아 있을 경우, `kube-controller-manager`에서 설정된 임계값을 초과하면 자동으로 정리된다.

    - **정리 조건**:
        - 고아 파드: 노드에서 제거된 파드나 종료 중인 파드
        - 스케줄되지 않은 종료 중인 파드
        - `NodeOutOfServiceVolumeDetach` 기능 게이트가 활성화된 상태에서, 준비되지 않은 노드에 있는 종료 중인 파드
    - **기타 조건**:
        - PodGC는 또한 `PodDisruptionConditions` 기능 게이트가 활성화된 경우 파드 중단 조건을 추가하며, 실패한 파드를 실패 상태로 표시한다.