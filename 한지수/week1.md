# 쿠버네티스 개념 & CLI 도구

## 1. 쿠버네티스란 무엇인가?

### 개념
쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성과 확장성을 갖춘 오픈소스 플랫폼이다. 선언적 구성과 자동화를 지원하며, 빠르게 성장하는 생태계를 갖추고 있다.

### **기술적 배경**
- **전통적인 배포 시대**  
  초기에는 한 물리 서버에서 여러 애플리케이션을 실행했지만 성능 저하 문제가 발생했다. 이를 해결하기 위해 각 애플리케이션을 별도의 물리 서버에서 실행했으나, 이 방식은 확장성과 비용 문제를 초래했다.

- **가상화된 배포 시대**  
  단일 물리 서버의 CPU를 활용해 여러 가상 머신(VM)을 실행하면 일정 수준의 보안성과 더 나은 확장성을 제공할 수 있다. 가상화를 통해 물리적 리소스를 폐기 가능한 VM으로 구성된 클러스터로 전환할 수 있다. 각 VM은 가상화된 하드웨어에서 자체 운영체제와 모든 구성 요소를 갖춘 완전한 독립 시스템으로 동작한다.

- **컨테이너 시대**  
  컨테이너는 VM과 유사하지만 격리 수준을 완화해 애플리케이션 간에 운영체제(OS)를 공유하므로 가볍다는 특징이 있다. VM과 마찬가지로 자체 파일 시스템, CPU 점유율, 메모리, 프로세스 공간을 가지며, 인프라에 종속되지 않아 다양한 클라우드 및 OS 배포판에서 이식성이 뛰어나다.

### **쿠버네티스의 기능**
컨테이너는 애플리케이션 실행에 효율적이지만, 프로덕션 환경에서는 장애 시 자동 복구가 필요하다. 이를 자동화하는 쿠버네티스는 확장, 장애 조치, 배포 패턴 관리 등을 제공해 안정적인 시스템 운영을 돕는다.
- **서비스 디스커버리와 로드 밸런싱**: DNS나 IP를 통해 컨테이너를 노출하고 트래픽을 로드밸런싱하여 자동으로 분산시킨다.
- **스토리지 오케스트레이션**: 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재한다.
- **자동화된 롤아웃과 롤백**: 쿠버네티스를 통해 컨테이너의 원하는 상태를 정의하고, 설정한 속도에 맞춰 해당 상태로 자동 조정할 수 있다.
- **자동화된 복구**: 컨테이너 장애 시 자동으로 복구하거나 교체한다. 이 과정은 클라이언트에 보여주지 않는다.
- **시크릿 및 구성 관리**: 민감한 정보를 안전하게 저장하고 관리한다.

### **쿠버네티스가 아닌 것**
쿠버네티스는 전통적인 PaaS가 아닌 컨테이너 중심 플랫폼으로, 배포, 스케일링, 로드 밸런싱 기능을 제공하면서도 로깅, 모니터링 등은 사용자가 선택해 통합할 수 있다.  
쿠버네티스는 다양한 워크로드를 지원하며, 소스 코드 배포, 빌드, 애플리케이션 레벨 서비스 제공 등은 하지 않는다. 또한 로깅, 모니터링, 경보 솔루션이 포함되지 않으며, 선언적 API를 통해 설정을 관리한다.  
쿠버네티스는 A → B → C 순서로 진행하는 전통적 오케스트레이션이 아닌, 독립적 제어 프로세스를 통해 지속적으로 원하는 상태로 조정해 유연하고 강력한 시스템을 구축할 수 있다.

---

## 2. 쿠버네티스 컴포넌트
쿠버네티스 클러스터는 컴퓨터 집합인 노드 컴포넌트와, 클러스터의 상태를 관리하는 컨트롤 플레인 컴포넌트로 구성된다.  
클러스터는 최소한 하나의 워커 노드를 가지고 있으며, 이 워커 노드는 컨테이너화된 애플리케이션을 실행하는 파드를 호스트한다.  
컨트롤 플레인은 클러스터 내의 파드와 워커 노드를 관리하며, 클러스터의 전체 상태를 제어한다. 일반적으로 여러 컴퓨터에 걸쳐 실행되는 컨트롤 플레인과 여러 노드를 실행시키는 클러스터로 내결함성과 고가용성을 제공한다.  
![image.png](attachment:5f0ca4d9-9832-4603-8523-6c9f4b44c618:image.png)

### **컨트롤 플레인 컴포넌트**
쿠버네티스 클러스터의 전반적인 결정을 내리고, 클러스터 이벤트를 감지하고 반응하는 역할을 한다. 일반적으로 모든 컨트롤 플레인 컴포넌트를 동일한 머신에서 실행하고, 사용자 컨테이너는 다른 머신에서 실행한다.
- **kube-apiserver**: 쿠버네티스의 API를 노출하는 API서버의 주요 구현체로, 프론트엔드 역할을 한다. 더 많은 인스턴스를 배포하여 수평 확장이 가능하다.
- **kube-scheduler**: 노드가 배정되지 않은 새로 생성된 파드를 감지하고, 이를 실행할 노드를 선택한다. 리소스에 대한 개별 및 총체적 요구 사항, 하드웨어, 소프트웨어, 정책적 제약, 어피니티와 안티-어피니티 명세, 데이터 지역성, 워크로드 간 간섭, 데드라인을 포함하여 스케줄링 결정을 내린다.
- **kube-controller-manager**: 컨트롤러 프로세스를 실행하는데, 여러 컨트롤러는 단일 프로세스 내에서 실행된다. 노드가 다운되었을 때 대응하는 노드 컨트롤러, 일회성 작업을 수행하는 잡 컨트롤러, 서비스와 파드 간 연결을 관리하는 엔드포인트슬라이스 컨트롤러, 새로운 네임스페이스에 기본 서비스어카운트를 생성하는 서비스어카운트 컨트롤러를 포함한다.
- **cloud-controller-manager**: 클러스터가 클라우드 공급자의 API와 연결되도록 하며, 여러 독립적인 컨트롤 루프를 단일 프로세스로 실행한다. 클라우드 제공자 전용 컨트롤러만 실행한다. 노드가 클라우드에서 삭제되었는지 확인하는 노드 컨트롤러, 클라우드 인프라에 경로를 구성하는 라우트 컨트롤러, 클라우드 제공 사업자의 로드밸런서를 관리하는 서비스 컨트롤러가 있다.

### **노드 컴포넌트**
동작 중인 파드를 유지시키고 쿠버네티스 런타임 환경을 제공하며, 모든 노드 상에서 동작한다.
- **kubelet**: 클러스터의 각 노드에서 실행되는 에이전트로, 파드에서 컨테이너가 정상적으로 동작하도록 관리하는 역할을 한다. 주어진 파드 스펙에 따라 컨테이너가 건강하게 동작하도록 보장한다.
- **kube-proxy**: 클러스터의 각 노드에서 실행되는 네트워크 프록시이다. 노드의 네트워크 규칙을 유지 관리하여 내부 네트워크 세션이나 클러스터 외부에서 파드로의 네트워크 통신을 가능하게 한다. 또한, 운영 체제에 패킷 필터링 계층이 가용하면 이를 사용하고, 그렇지 않으면 트래픽을 직접 포워딩한다.
- **컨테이너 런타임**: 컨테이너 실행을 담당하는 소프트웨어이다.

### **애드온**
쿠버네티스 리소스를 이용하여 클러스터 기능을 구현한다. 클러스터 단위의 기능을 제공하기 때문에 애드온에 대한 네임스페이스 리소스는 `kube-system` 네임스페이스에 속한다.
- **DNS**: 쿠버네티스 서비스를 위해 DNS 레코드를 제공해주는 DNS 서버이다. 쿠버네티스에 의해 구동되는 컨테이너는 DNS 검색에서 이 DNS 서버를 자동으로 포함한다.
- **웹 UI (대시보드)**: 쿠버네티스 클러스터를 위한 범용의 웹 기반 UI다.
- **컨테이너 리소스 모니터링**: 중앙 데이터베이스 내의 컨테이너들에 대한 포괄적인 시계열 매트릭스를 기록하고 그 데이터를 열람하기 위한 UI를 제공한다.
- **클러스터-레벨 로깅**: 중앙 데이터베이스 내의 컨테이너들에 대한 포괄적인 시계열 매트릭스를 기록하고 그 데이터를 열람하기 위한 UI를 제공한다.

---
## **3. 쿠버네티스 API**

쿠버네티스 오브젝트들의 상태를 쿼리하고 조작할 수 있게 해주는 핵심 기능으로 API 서버를 통해 제공된다. API 서버는 HTTP API를 통해 사용자, 클러스터의 다른 부분, 외부 컴포넌트가 서로 통신할 수 있도록 한다.

대부분의 작업은 kubectl CLI나 kubeadm과 같은 도구를 통해 수행되며, REST 호출을 사용해 API에 직접 접근할 수도 있다. 애플리케이션을 개발할 때는 클라이언트 라이브러리를 사용하는 것이 권장된다.

### **OpenAPI 명세**

1. **OpenAPI V2**

   안정적인 상태에서 API의 리소스를 정의하고 제공하는 데 사용된다.


| 헤더 | 사용 가능한 값 | 참고 |
| --- | --- | --- |
| Accept-Encoding | gzip | 이 헤더를 제공하지 않는 것도 가능 |
| Accept | application/com.github.proto-openapi.spec.v2@v1.0+protobuf | 주로 클러스터 내부 용도로 사용 |
|  | application/json | 기본값, JSON으로 응답 |
2. **OpenAPI V3**

   Kubernetes v1.32부터 베타 기능으로 제공되며, 더 구체적인 그룹과 버전 정보를 포함하고 JSON 형식으로만 응답을 제공한다.


| 헤더 | 사용 가능한 값 | 참고 |
| --- | --- | --- |
| Accept-Encoding | gzip | 이 헤더를 제공하지 않는 것도 가능 |
| Accept | application/com.github.proto-openapi.spec.v3@v1.0+protobuf | 주로 클러스터 내부 용도로 사용 |
|  | application/json | 기본값 |
|  | * | JSON으로 응답 |

### **지속성**

쿠버네티스는 etcd에 직렬화된 상태를 기록하여 오브젝트의 지속성을 유지한다.

### **API 그룹과 버전 규칙**

각 API는 경로 `/api/v1` 또는 `/apis/<group>/<version>` 형태로 구분된다. 리소스는 그룹, 버전, 리소스 유형, 네임스페이스, 이름 등으로 식별되며, 동일한 리소스에 대해 여러 버전(v1, v1beta1 등)을 제공하여 사용자가 적절한 버전을 선택할 수 있다.

### **API 변경 사항 및 확장**

쿠버네티스는 지속적으로 성장하며 변화를 수용하기 위해 새로운 API 버전을 추가하거나 리소스 및 필드를 제거할 수 있다.
API 확장은 커스텀 리소스를 사용하여 선언적으로 리소스를 정의하거나, 애그리게이션 레이어를 통해 확장할 수 있다.

---

## **4. 명령줄 도구 (kubectl)**

kubectl은 쿠버네티스 API를 통해 쿠버네티스 클러스터의 컨트롤 플레인과 통신하는 커맨드라인 도구이다. 기본적으로 kubectl은 구성 파일을 `$HOME/.kube` 에서 찾으며, `KUBECONFIG` 환경 변수를 설정하거나 `--kubeconfig` 플래그를 사용해 다른 kubeconfig 파일을 지정할 수도 있다.

### **구문**

kubectl 명령어의 기본 구문은 아래의 형식을 따른다.

```bash
kubectl [command] [TYPE] [NAME] [flags]
```

- **command**

  리소스에서 수행할 동작을 지정한다.

  예: `create`, `get`, `describe`, `delete` 등

- **TYPE**

  리소스 타입을 지정하며, 대소문자를 구분하지 않고 단수형, 복수형, 약어 모두 사용

  예: `pod`, `pods`, `po` 등

- **NAME**

  리소스 이름을 지정하며, 생략 시 모든 리소스를 표시한다.여러 리소스를 지정할 때는 다음 방법을 사용할 수 있다.

    - 동일한 타입의 여러 리소스: `kubectl get pod example-pod1 example-pod2`
    - 여러 리소스 타입 혼합: `kubectl get pod/example-pod1 rc/example-rc1`
    - 파일로 지정: `kubectl get -f ./pod.yaml`
- **flags**

  선택적 플래그를 지정한다.

  예: `-s` 또는 `--server`를 통해 API 서버 주소를 지정


명령어 플래그는 기본값과 환경 변수를 무시하며,  도움말은 `kubectl help`로 확인할 수 있다.

### **클러스터 내 인증과 네임스페이스 오버라이드**

1. **실행 여부의 판별**

kubectl은 기본적으로 자신이 클러스터 내부에서 실행 중인지 확인하기 위해 다음을 검사한다.

- `KUBERNETES_SERVICE_HOST` 환경 변수
- `KUBERNETES_SERVICE_PORT` 환경 변수
- `/var/run/secrets/kubernetes.io/serviceaccount/token` 경로의 서비스 어카운트 토큰 파일

이 세 가지가 모두 감지되면, kubectl은 클러스터 내부에서 실행되고 있다고 판단하고 해당 네임스페이스에 대해 동작한다.

2. **POD_NAMESPACE 환경 변수**

`POD_NAMESPACE` 환경 변수가 설정되어 있으면, kubectl 명령은 해당 네임스페이스를 기본값으로 사용한다. 명시적으로 `-namespace <value>`를 지정하면 이 동작을 덮어쓴다.
3. **kubectl이 서비스어카운트 토큰을 관리하는 방법**

클러스터 내부에서는 파드의 네임스페이스를 인식해 해당 네임스페이스에서 동작한다.

클러스터 외부에서는 현재 컨텍스트의 네임스페이스에 대해 동작한다.

기본 네임스페이스를 변경하려면 다음 명령을 사용한다.

```bash
kubectl config set-context --current --namespace=<namespace-name>
```

### **명령어**

주요한 명령어는 다음과 같다.

| 명령어 | 설명 |
| --- | --- |
| apply | 리소스 구성 변경 사항 적용 |
| attach | 실행 중인 컨테이너에 연결하여 상호작용 |
| create | 리소스 생성 |
| delete | 리소스 삭제 |
| describe | 리소스의 상세 정보 표시 |
| exec | 컨테이너 내 명령 실행 |
| expose | 레플리케이션 컨트롤러/서비스/파드 노출 |
| get | 리소스 목록 출력 |
| logs | 파드의 로그 출력 |
| port-forward | 로컬 포트 → 파드 포트 연결 |
| rollout | 디플로이먼트/데몬셋 롤아웃 관리 |
| run | 클러스터에 이미지 실행 |
| scale | 레플리케이션 컨트롤러 크기 조정 |
| top | 리소스(CPU/메모리) 사용량 표시 |

### **리소스 타입**

주요한 리소스 타입은 다음과 같다.

| 이름 | 약어 | API 버전 | 종류 |
| --- | --- | --- | --- |
| **bindings** | - | v1 | Binding |
| **configmaps** | cm | v1 | ConfigMap |
| **endpoints** | ep | v1 | Endpoints |
| **limitranges** | limits | v1 | LimitRange |
| **pods** | po | v1 | Pod |
| **replicationcontrollers** | rc | v1 | ReplicationController |
| **secrets** | - | v1 | Secret |
| **serviceaccounts** | sa | v1 | ServiceAccount |
| **services** | svc | v1 | Service |
| **customresourcedefinitions** | crd, crds | [apiextensions.k8s.io/v1](http://apiextensions.k8s.io/v1) | CustomResourceDefinition |

### **출력 서식화 옵션**

`o` 또는 `-output` 플래그를 사용하여 특정 형식으로 데이터를 출력할 수 있다.

```bash
kubectl [command] [TYPE] [NAME] -o <output_format>
```

| **출력 형식** | **설명** |
| --- | --- |
| `-o custom-columns=<spec>` | 쉼표로 구분된 사용자 정의 열 목록을 사용해 테이블을 출력 |
| `-o custom-columns-file=<파일>` | 파일에 정의된 사용자 정의 열 템플릿을 사용해 테이블 출력 |
| `-o json` | JSON 형식으로 출력 |
| `-o jsonpath=<template>` | `jsonpath` 표현식을 사용해 필드 출력 |
| `-o jsonpath-file=<파일>` | 파일에 정의된 `jsonpath` 표현식을 사용해 필드 출력 |
| `-o name` | 리소스 이름만 출력 |
| `-o wide` | 추가 정보가 포함된 일반 텍스트 형식으로 출력 (예: 파드의 경우 노드 이름 포함) |
| `-o yaml` | YAML 형식으로 출력 |

### **사용자 정의 열**

- `custom-columns`

사용자 정의 열을 정의하고 원하는 세부 정보만 테이블에 출력

- `-o custom-columns=<spec>` 또는 `-o custom-columns-file=<filename>`

사용자 정의 열을 인라인으로 정의하거나 템플릿 파일을 사용하도록 선택할 수 있다

### **서버측 열**

- `kubectl`

  해당 리소스와 관련된 열과 행을 반환

  서버가 출력의 세부 사항을 캡슐화하도록 하여, 동일한 클러스터에 대해 사용된 클라이언트에서 사람이 읽을 수 있는 일관된 출력을 허용한다.

- `kubectl get` 명령에 `--server-print=false`

  위 기능을 사용하지 않으려면,  해당 플래그를 추가한다.


### **오브젝트 목록 정렬 (Sorting)**

`-sort-by` 플래그를 사용하면 JSONPath 표현식을 이용해 오브젝트를 정렬할 수 있다.

```bash
kubectl [command] [TYPE] [NAME] --sort-by=<jsonpath_exp>
```

---

## **5. Kubeadm**

Kubeadm은 쿠버네티스 클러스터를 쉽게 생성할 수 있도록 돕는 도구로, `kubeadm init`과 `kubeadm join` 명령을 제공하여 빠르고 표준화된 클러스터 구성을 지원한다.

Kubeadm의 주요 역할은 최소한의 클러스터를 시작하고 실행하는 데 필요한 작업을 수행하는 것이다. 그러나 시스템 프로비저닝이나, 쿠버네티스 대시보드, 모니터링 솔루션, 클라우드별 애드온 등 추가적인 기능들은 제공하지 않는다.

Kubeadm은 기본적인 클러스터 구성만 다루며, 고급 기능은 더 높은 수준의 맞춤형 도구들이 kubeadm 위에 구축되어야 한다. 이를 통해 표준을 따르는 클러스터를 쉽게 생성할 수 있다.

---

## 6. Kubelet 구성 파일을 통한 파라미터 설정

Kubelet의 구성 파라미터는 디스크의 구성 파일을 통해 설정할 수 있으며, 이는 명령줄 플래그를 대체하는 방식이다. 구성 파일을 통한 파라미터 제공은 노드 배포와 구성 관리를 단순화하므로 권장되는 방식이다.

### 구성 파일 생성

1. 구성 파일 형식

   KubeletConfiguration 구조체의 파라미터를 JSON 또는 YAML 형식으로 표현한다.

   apiVersion과 kind와 같은 타입 메타데이터 포함이 필수이다.

   Kubelet이 파일에 대한 읽기 권한을 가지고 있어야 한다.

2. 구성 파일 예시

    ```bash
    apiVersion: kubelet.config.k8s.io/v1beta1
    kind: KubeletConfiguration
    address: "192.168.0.8"
    port: 20250
    serializeImagePulls: false
    evictionHard:
      memory.available: "100Mi"
      nodefs.available: "10%"
      nodefs.inodesFree: "5%"
      imagefs.available: "15%"
      imagefs.inodesFree: "5%"`
    ```

    - IP 주소 192.168.0.8의 포트 20250에서 서비스 제공
    - 이미지 풀을 병렬로 수행
    - Pod 퇴거 조건 설정:
        - 노드의 사용 가능한 메모리가 100MiB 미만
        - 주 파일시스템의 사용 가능한 공간이 10% 미만
        - 이미지 파일시스템의 공간이 15% 미만
        - 주 파일시스템의 inode 사용률이 95% 이상

### 구성 파일 적용 방법

1. kubeadm 사용 시:

   kubeadm init 실행 시 kubelet-config를 통해 구성한다.

2. 단독 실행 시:

   -config 플래그에 구성 파일 경로를 지정하여 Kubelet를 시작한다.

   명령줄 플래그가 구성 파일의 동일 값보다 우선순위가 높다

   상대 경로는 구성 파일 위치 기준으로 해석한다.


### Drop-in 디렉토리 기능 (v1.30 베타)

-config-dir 플래그로 디렉토리 지정이 필요하다.

구성 파일은 .conf 확장자를 가져야 한다.

파일은 알파벳순으로 처리되어 나중에 오는 파일이 이전 설정을 덮어쓴다.

v1.28-v1.29에서는 KUBELET_CONFIG_DROPIN_DIR_ALPHA 환경변수 설정이 필요하다.

### 구성 병합 순서

우선순위를 낮은 쪽에서 높은 쪽으로 정렬했을 때 다음과 같다.

1. 명령줄 feature gates
2. kubelet 기본 구성
3. Drop-in 구성 파일 (알파벳순)
4. 명령줄 인자 (feature gates 제외)

구성 확인은 kubectl proxy를 실행한 후 curl 명령으로 노드의 configz 엔드포인트에 접근하여 현재 적용된 모든 설정을 JSON 형식으로 확인할 수 있다.