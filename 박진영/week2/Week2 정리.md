# Week2

# 파드(Pod)

- 쿠버네티스에서 생성&관리 가능한, 배포 가능한 가장 작은 점퓨팅 단위
- 하나 이상의 컨테이너 그룹
    - 스토리지 및 네트워크 공유
    - 해당 컨테이너 구동 방식에 대한 명세를 가짐
    - 파드 콘텐츠는 항상 함께 배치되고, 스케줄됨
    - 공유 context에서 실행됨
- 애플리케이션 별 “논리 호스트”를 모델링함
    - 하나 이상의 애플리케이션 컨테이너가 포함됨
    - 클라우드가 아닌 콘텍스트에서, 동일한 물리/가상 머신에서 실행되는 애플리케이션은, 논리 호스트에서 실행되는 클라우드 애플리케이션과 유사
- 파드 시작 중에 실행되는 초기화 컨테이너가 포함될 수 있음.
- 디버깅을 위한 임시 컨테이너 삽입 가능

## 파드가 무엇인가?

- 파드의 공유 콘텍스트 : 리눅스 네임스페이스, 컨트롤 그룹(cgroup) 및 컨테이너를 격리하는 것과 같이 잠재적으로 다른 격리 요소들
- 파드 콘텍스트 내에서 개별 애플리케이션은 추가적으로 하위 격리가 적용됨

## 파드의 사용

- 파드 생성 명령어
    
    `kubectl apply -f https://k8s.io/examples/pods/{명세서이름}.yaml`
    
- 파드는 일반적으로 직접 생성하지는 않고, 워크로드 리소스를 사용하여 생성함
- 쿠버네티스 클러스터의 파드가 사용되는 두 가지 방식
    1. 단일 컨테이너 실행하는 파드(일반적)
    2. 함께 작동해야 하는 여러 컨테이너를 실행하는 파드
        
        ![](https://kubernetes.io/images/docs/pod.svg)
        
- 각 파드는 특정 애플리케이션의 단일 인스턴스를 실행하기 위한 것
→ 더 많은 인스턴스 실행으로 애플리케이션을 수평적으로 확장하려면, 각 인스턴스에 하나씩, 여러 파드를 사용해야 함
⇒ **“레플리케이션”**
 : 복제된 파드는 일반적으로 워크로드 리소스와 해당 컨트롤러에 의해 그룹으로 생성되고 관리됨

## 파드 작업

- 파드 실행 시 OS 표시하려면 → `.spec.os.name` 필드를 `windows` 또는 `linux`로 설정(유일하게 지원되는 OS)
- 파드와 컨트롤러
    
    파드를 컨트롤러로서 관리하는 워크로드 리소스
    
    - 디플로이먼트
    - 스테이트풀셋
    - 데몬셋(DaemonSet)
- 파드 템플릿(PodTemplate)
    - 파드 생성을 위한 명세
        - 워크로드 리소스의 각 컨트롤러는 워크로드 오브젝트 내부의 `PodTemplate` 을 사용하여 실제 파드를 생성
    - 워크로드 리소스에 포함됨

## 파드 갱신 및 교체

- 워크로드 리소스의 파드 템플릿이 바뀌면, 컨트롤러는 기존의 파드를 갱신하거나 패치하는 대신 갱신된 템플릿을 기반으로 신규 파드를 생성
- 파드에 대한 대부분의 메타데이터는 불변(immutable)
    - 사용자는 `namespace`, `name`, `uid`, 또는 `creationTimestamp` 필드를 변경할 수 없음
    - `generation` 필드는 고유하여, 필드의 현재 값을 증가시키는 갱신만 허용
- `metadata.deletionTimestamp` 가 설정된 경우, `metadata.finalizers` 리스트에 새로운 항목이 추가될 수 없음
- 파드 갱신은 `spec.containers[*].image`, `spec.initContainers[*].image`, `spec.activeDeadlineSeconds`, 또는 `spec.tolerations` 이외의 필드는 변경하지 않을 것
- `spec.tolerations` 에 대해서만 새로운 항목을 추가할 수 있음
- `spec.activeDeadlineSeconds` 필드를 추가할 때는, 다음의 두 가지 형태의 갱신만 허용
    1. 지정되지 않은 필드를 양수로 설정
    2. 필드의 양수를 음수가 아닌 더 작은 숫자로 갱신

## 리소스 공유와 통신

- 파드는 파드에 속한 컨테이너 간의 데이터 공유와 통신을 지원함

### 파드 스토리지

- 공유 스토리지 볼륨의 집합을 지정
- 파드의 모든 컨테이너는 공유 볼륨에 접근 가능 → 해당 컨테이너가 데이터를 공유할 수 있음
- 볼륨은 내부 컨테이너 중 하나를 다시 시작해야 하는 경우 파드의 영구 데이터를 유지하게 함

### 파드 네트워킹

- 각 파드에는 각 주소 패밀리에 대해 고유한 IP 주소가 할당됨
- 파드 내부(이 경우에 **만** 해당)에서, 파드에 속한 컨테이너는 `localhost` 를 사용하여 서로 통신할 수 있음
    - SystemV 세마포어 또는 POSIX 공유 메모리와 같은 표준 프로세스 간 통신
- *파드 외부의* 엔티티와 통신할 때, 공유 네트워크 리소스(포트와 같은)를 사용하는 방법을 조정해야 함
    - 특별한 구성 없이 OS 수준의 IPC로 통신할 수 없다
    - 다른 파드에서 실행되는 컨테이너와 상호 작용하려는 컨테이너는 IP 네트워킹을 사용하여 통신 가능

### 컨테이너에 대한 특권 모드

- 파드의 모든 컨테이너는 컨테이너 명세의 보안 컨텍스트에 있는 `privileged` (리눅스) 플래그를 사용하여 특권 모드를 활성화할 수 있음
- 클러스터가 `WindowsHostProcessContainers` 기능을 활성화하였다면, 파드 스펙의 보안 컨텍스트의 `windowsOptions.hostProcess` 에 의해 윈도우 HostProcess 파드를 생성할 수 있음

### 정적 파드

- API 서버가 관찰하는 대신 특정 노드의 kubelet 데몬에 의해 직접 관리됨
- 대부분의 파드는 컨트롤 플레인(e.g. 디플로이먼트)에 의해 관리됨
- 정적 파드의 경우, kubelet이 각 정적 파드를 직접 감독(실패하면 다시 시작)
    - 항상 특정 노드의 Kubelet 하나에 바인딩됨

### 컨테이너 프로브

: 컨테이너의 kubelet에 의해 주기적으로 실행되는 진단

kubelet은 다음과 같은 작업을 호출 가능

- `ExecAction` (컨테이너 런타임의 도움을 받아 수행)
- `TCPSocketAction` (kubelet에 의해 직접 검사)
- `HTTPGetAction` (kubelet에 의해 직접 검사)

# 파드 라이프사이클

1. Pending
2. Running : 기본 컨테이너 중 적어도 하나 이상이 OK로 시작하면 통과
3. 파드 컨테이너가 실패로 종료되었는지 여부 판단 → Succeeded/Failed
4. 파드 내에서 k8s는 컨테이너 상태를 추적하고 파드를 정상 상태로 만들고자 조치 결정
- 쿠버네티스 API에서 파드는 명세&실제 상태 모두 가짐
- 파드의 수명 중 한 번만 scheduled.
    - 파드가 노드에 스케줄되면(할당되면), 파드는 중지/종료될 대까지 해당 노드에서 실행됨

## 파드의 수명

- 자가치유되지 않음. 실패 시 바로 파드는 삭제됨.
- k8s는 컨트롤러(high-level 추상화)로 상대적으로 일회용인 파드 인스턴스를 관리함
- UID로 정의된 특정 파드는 다른 노드로 절대 “다시 스케줄”되지 않음.
대신 해당 파드는 사용자가 원하면 동명이되 다른 UID인 파드로 대체될 수 있음

## 파드의 단계(phase)

`status` 필드는 `phase` 필드를 포함하는 PodStatus 오브젝트로 정의됨

| 값 | 의미 |
| --- | --- |
| `Pending` | 파드가 쿠버네티스 클러스터에서 승인되었지만, 하나 이상의 컨테이너가 설정되지 않았고 실행할 준비가 되지 않았다. 여기에는 파드가 스케줄되기 이전까지의 시간 뿐만 아니라 네트워크를 통한 컨테이너 이미지 다운로드 시간도 포함된다. |
| `Running` | 파드가 노드에 바인딩되었고, 모든 컨테이너가 생성되었다. 적어도 하나의 컨테이너가 아직 실행 중이거나, 시작 또는 재시작 중에 있다. |
| `Succeeded` | 파드에 있는 모든 컨테이너들이 성공적으로 종료되었고, 재시작되지 않을 것이다. |
| `Failed` | 파드에 있는 모든 컨테이너가 종료되었고, 적어도 하나 이상의 컨테이너가 실패로 종료되었다. 즉, 해당 컨테이너는 non-zero 상태로 빠져나왔거나(exited) 시스템에 의해서 종료(terminated)되었다. |
| `Unknown` | 어떤 이유에 의해서 파드의 상태를 얻을 수 없다. 이 단계는 일반적으로 파드가 실행되어야 하는 노드와의 통신 오류로 인해 발생한다. |
- 노드가 죽거나 클러스터의 나머지와의 연결이 끊어지면, 쿠버네티스는 손실된 노드의 모든 파드의 `phase` 를 Failed로 설정

## 컨테이너 상태

- Waiting
- Running
- Terminated

## 컨테이너 재시작 정책

`spec`에 있는 `restartPolicy` 

- 기본값은 Always
- OnFailure, Never 사용 가능

## 파드의 컨디션

`PodStatus`

- `PodScheduled`
- `PodHasNetwork`
- `ContainersReady`
- `Initialized`
- `Ready`

## 파드의 준비성(readiness)

`spec` 내 `readinessGate` 

## 컨테이너 Probe

- 컨테이너에서 kubelet에 의해 주기적으로 수행되는 진단(diagnostic)
- kubelet은 컨테이너 안에서 코드를 실행하거나 네트워크 요청을 전송함

### 체크 메커니즘

프로브로 컨테이너를 체크하는 네 가지 방법(단 하나만 선택하기)

1. exec
    - 컨테이너 내에서 지정된 명령어를 실행
    - 상태코드 0으로 종료되면 성공
2. grpc
    - 원격 프로시저 호출을 수행
    - status가 SERVING이면 진단 성공
    - `GRPCContainerProbe` 기능 게이트를 활성화해야 사용할 수 있음
3. httpGet
    - 응답의 상태 코드가 200 이상 400 미만이면 진단이 성공
4. tcpSocket
    - 지정된 포트에서 컨테이너의 IP주소에 대해 TCP 검사를 수행
    - 포트 활성화 시 진단 성공
    - 원격 시스템(컨테이너)가 연결을 연 이후 즉시 닫는다면, 이 또한 진단이 성공

### 프로브 종류

1. livenessProbe
    - 컨테이너 속 프로세스가 어떠한 이슈에 직면하거나 건강하지 못한 상태(unhealthy)가 되는 등 프로세스 자체의 문제로 중단될 수 있더라도, 활성 프로브가 반드시 필요한 것은 아님
    → kubelet이 파드의 `restartPolicy`에 따라서 올바른 대처를 자동적으로 수행할 것
    - 프로브가 실패한 후 컨테이너가 종료되거나 재시작되길 원한다면, 활성 프로브를 지정하고, `restartPolicy`를 항상(Always) 또는 실패 시(OnFailure)로 지정
2. readinessProbe
    - 프로브가 성공한 경우에만 파드에 트래픽 전송을 시작하려고 하는 경우
    - 파드가 트래픽을 받지 않는 상태에서 시작되고 프로브가 성공하기 시작한 이후에만 트래픽을 받는다는 뜻
3. startupProbe
    - 서비스를 시작하는 데 오랜 시간이 걸리는 컨테이너가 있는 파드에 유용